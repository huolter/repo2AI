# This is the structure of the repository and its contents:

root
- cryptos
  - cryptos-main
    - .gitignore
    - README.md
    - blog.ipynb
    - cryptos
      - __init__.py
      - bitcoin.py
      - block.py
      - curves.py
      - ecdsa.py
      - keys.py
      - network.py
      - ripemd160.py
      - sha256.py
      - transaction.py
    - getnewaddress.py
    - tests
      - __init__.py
      - test_block.py
      - test_ecdsa.py
      - test_hash.py
      - test_keys.py
      - test_network.py
      - test_tx.py


# The following are the contents of the repository:


## Content of getnewaddress.py

```python
"""
A cli tool that generates and prints a new Bitcoin address.
Specifically, the tool prints:
- a new secret key
- the associated public key
- the bitcoin address
"""

from cryptos.keys import gen_secret_key, PublicKey
from cryptos.bitcoin import BITCOIN

if __name__ == '__main__':

    # generate a secret/public key pair
    secret_key = gen_secret_key(BITCOIN.gen.n)
    public_key = PublicKey.from_sk(secret_key)
    print('generated secret key:')
    print(hex(secret_key))
    print('corresponding public key:')
    print('x:', format(public_key.x, '064x').upper())
    print('y:', format(public_key.y, '064x').upper())

    # get the associated bitcoin address
    addr = public_key.address(net='main', compressed=True)
    print('compressed bitcoin address (b58check format):')
    print(addr)

```


## Content of README.md

```markdown

# cryptos

Just me developing a pure Python from-scratch zero-dependency implementation of Bitcoin for educational purposes, including all of the under the hood crypto primitives such as SHA-256 and elliptic curves over finite fields math.

### SHA-256

My pure Python SHA-256 implementation closely following the [NIST FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf) spec, in `cryptos/sha256.py`. Since this is a from scratch pure Python implementation it is slow and obviously not to be used anywhere except for educational purposes. Example usage:

```bash
$ echo "some test file lol" > testfile.txt
$ shasum -a 256 testfile.txt
4a79aed64097a0cd9e87f1e88e9ad771ddb5c5d762b3c3bbf02adf3112d5d375
$ python -m cryptos.sha256 testfile.txt
4a79aed64097a0cd9e87f1e88e9ad771ddb5c5d762b3c3bbf02adf3112d5d375
```

### Keys

`getnewaddress.py` is a cli entryway to generate a new Bitcoin secret/public key pair and the corresponding (base58check compressed) address:

```bash
$ python getnewaddress.py
generated secret key:
0xc322622e6a0033bb93ff666753f77cc8b819d274d9edea007b7e4b2af4caf025
corresponding public key:
x: 5B9D87FE091D52EA4CD49EA5CEFDD8C099DF7E6CCF510A9A94C763DE38C575D5
y: 6049637B3683076C5568EC723CF7D38FD603B88447180829BBB508C554EEA413
compressed bitcoin address (b58check format):
1DBGfUXnwTS2PRu8h3JefU9uYwYnyaTd2z
```

### Digital Signatures

Elliptic Curve Digital Signature Algorithm (ECDSA) implemented in `cryptos/ecdsa.py`, example usage:

```python
>>> from cryptos.keys import gen_key_pair
>>> from cryptos.ecdsa import sign, verify
>>> sk1, pk1 = gen_key_pair()
>>> sk2, pk2 = gen_key_pair()
>>> message = ('pk1 wants to pay pk2 1 BTC').encode('ascii')
>>> sig = sign(sk1, message)
>>> verify(pk1, message, sig)
True
>>> verify(pk2, message, sig)
False
```

### Transactions

Bitcoin transaction objects (both legacy or segwit) can be instantiated and parsed from raw bytes. An example of parsing a legacy type transaction:

```python
>>> from cryptos.transaction import Tx
>>> from io import BytesIO

>>> # example transaction in Programming Bitcoing Chapter 5
>>> raw = bytes.fromhex('0100000001813f79011acb80925dfe69b3def355fe914bd1d96a3f5f71bf8303c6a989c7d1000000006b483045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031ccfcf21320b0277457c98f02207a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9c8e10615bed01210349fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e213bf016b278afeffffff02a135ef01000000001976a914bc3b654dca7e56b04dca18f2566cdaf02e8d9ada88ac99c39800000000001976a9141c4bc762dd5423e332166702cb75f40df79fea1288ac19430600')
>>> tx = Tx.parse(BytesIO(raw))
>>> # we get back a Transaction object with parsed fields
>>> tx

Tx(version=1, tx_ins=[TxIn(prev_tx=b'\xd1\xc7\x89\xa9\xc6\x03\x83\xbfq_?j\xd9\xd1K\x91\xfeU\xf3\xde\xb3i\xfe]\x92\x80\xcb\x1a\x01y?\x81', prev_index=0, script_sig=3045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031ccfcf21320b0277457c98f02207a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9c8e10615bed01 0349fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e213bf016b278a, sequence=4294967294, witness=None)], tx_outs=[TxOut(amount=32454049, script_pubkey=OP_DUP OP_HASH160 bc3b654dca7e56b04dca18f2566cdaf02e8d9ada OP_EQUALVERIFY OP_CHECKSIG), TxOut(amount=10011545, script_pubkey=OP_DUP OP_HASH160 1c4bc762dd5423e332166702cb75f40df79fea12 OP_EQUALVERIFY OP_CHECKSIG)], locktime=410393, segwit=False)
```

And we can verify that the transaction is Bitcoin law-abiding and cryptographically authentic:

```python
>>> tx.validate()
True
```

This isn't exactly a complete verification as a Bitcoin full node would do and e.g. skips verification of double spends, script sizing limits, etc., and also it only supports the (simpler) p2pkh transactions. Notably, this does not include the "modern" segwit versions used predominantly in today's Bitcoin traffic since the soft fork of BIP141 around July 2017.

### Blocks

See `cryptos/block.py` for Block class, functions and utilities.

### Lightweight Node

A lightweight Bitcoin Node that speaks a subset of the [Bitcoin protocol](https://en.bitcoin.it/wiki/Protocol_documentation) is in `cryptos/network.py`. This node connects to other nodes using Python's `socket`, performs version handshake and then can request block headers. E.g. we can walk the first 40,000 blocks (in batches of 2,000) and partially validate them. A Bitcoin full node would fetch the full block (not just headers) with all transactions and also validate those, etc. But a partial validation would look like:

```python

from io import BytesIO
from cryptos.block import Block, GENESIS_BLOCK, calculate_new_bits
from cryptos.network import SimpleNode
from cryptos.network import (
    GetHeadersMessage,
    HeadersMessage,
)

# connect to a node and pretty please ask for
# 20 block headers starting with the genesis block

# Start with the genesis block
# https://en.bitcoin.it/wiki/Genesis_block
# class Block:
#     version: int        # 4 bytes little endian
#     prev_block: bytes   # 32 bytes, little endian
#     merkle_root: bytes  # 32 bytes, little endian
#     timestamp: int      # uint32, seconds since 1970-01-01T00:00 UTC
#     bits: bytes         # 4 bytes, current target in compact format
#     nonce: bytes        # 4 bytes, searched over in pow
previous = Block.decode(BytesIO(GENESIS_BLOCK['main']))

# okay now let's crawl the blockchain block headers
node = SimpleNode(
    host='mainnet.programmingbitcoin.com',
    net='main',
)
node.handshake()

blocks = [previous]
for _ in range(20):

    # request next batch of 2,000 headers
    getheaders = GetHeadersMessage(start_block=bytes.fromhex(previous.id()))
    node.send(getheaders)
    headers = node.wait_for(HeadersMessage)

    # extend our chain of block headers
    blocks.extend(headers.blocks)

    previous = headers.blocks[-1]
    print(f"received another batch of blocks, now have {len(blocks)}")

node.close()
# we now have 40,001 blocks total, 80 bytes each in raw, so total of ~3.2MB of data

# now (partially) validate blockchain integrity
for i, block in enumerate(blocks):

    # validate proof of work on this block
    assert block.validate()

    # validate pointer to the previous node matches
    prev = blocks[i - 1]
    expected_prev_block = b'\x00'*32 if i == 0 else bytes.fromhex(prev.id())
    assert block.prev_block == expected_prev_block

    # validate the proof of work target calculation on the block was correct
    if i % 2016 == 0:
        if i == 0:
            # genesis block had hardcoded value for bits
            expected_bits = bytes.fromhex('ffff001d')
        else:
            # recalculate the target at every epoch (2016 blocks), approx 2 week period
            # note that Satoshi had an off-by-one bug in this calculation because we are
            # looking at timestamp difference between first and last block in an epoch,
            # so these are only 2015 blocks apart instead of 2016 blocks apart ¯\_(ツ)_/¯
            prev_epoch = blocks[i - 2016]
            time_diff = prev.timestamp - prev_epoch.timestamp
            expected_bits = calculate_new_bits(prev.bits, time_diff)
    assert block.bits == expected_bits

    if i % 1000 == 0:
        print(f"on block {i+1}/{len(blocks)}")
```

It feels very nice to independently at least partially verify the integrity of the block chain :)

### Unit tests

```bash
$ pytest
```

### License
MIT

```


## Content of .gitignore

```
__pycache__/
.ipynb_checkpoints

```


## Content of blog.ipynb

```
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I find blockchain fascinating because it extends open source software development to open source + state. This seems to be a genuine/exciting innovation in computing paradigms; We don't just get to share code, we get to share a running computer, and anyone anywhere can use it in an open and permissionless manner. The seeds of this revolution arguably began with Bitcoin, so I became curious to drill into it in some detail to get an intuitive understanding of how it works. And in the spirit of \"what I cannot create I do not understand\", what better way to do this than implement it from scratch?\n",
    "\n",
    "**In this Jupyter Notebook we are going to create, digitally sign, and broadcast a Bitcoin transaction in pure Python, from scratch, and with zero dependencies.** In the process we're going to learn quite a bit about how Bitcoin represents value. Let's get it."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Step 1: generating a crypto identity\n",
    "\n",
    "First we want to generate a brand new cryptographic identity, which is just a private, public keypair. Bitcoin uses [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) instead of something more common like RSA to secure the transactions. I am not going to do a full introduction to ECC here because others have done a significantly better job, e.g. I found [Andrea Corbellini's blog post series](https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/) to be an exceptional resource. Here we are just going to write the code but to understand why it works mathematically you'd need to go through the series.\n",
    "\n",
    "Okay so Bitcoin uses the [secp256k1](https://en.bitcoin.it/wiki/Secp256k1) curve. As a newbie to the area I found this part fascinating - there are entire libraries of different curves you can choose from which offer different pros/cons and properties. NIST publishes recommendations on which ones to use, but people prefer to use other curves (like secp256k1) that are less likely to have backdoors built into them. Anyway, an elliptic curve is a fairly low dimensional mathematical object and takes only 3 integers to define:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {},
   "outputs": [],
   "source": [
    "from __future__ import annotations # PEP 563: Postponed Evaluation of Annotations\n",
    "from dataclasses import dataclass # https://docs.python.org/3/library/dataclasses.html I like these a lot\n",
    "\n",
    "@dataclass\n",
    "class Curve:\n",
    "    \"\"\"\n",
    "    Elliptic Curve over the field of integers modulo a prime.\n",
    "    Points on the curve satisfy y^2 = x^3 + a*x + b (mod p).\n",
    "    \"\"\"\n",
    "    p: int # the prime modulus of the finite field\n",
    "    a: int\n",
    "    b: int\n",
    "\n",
    "# secp256k1 uses a = 0, b = 7, so we're dealing with the curve y^2 = x^3 + 7 (mod p)\n",
    "bitcoin_curve = Curve(\n",
    "    p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F,\n",
    "    a = 0x0000000000000000000000000000000000000000000000000000000000000000, # a = 0\n",
    "    b = 0x0000000000000000000000000000000000000000000000000000000000000007, # b = 7\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In addition to the actual curve we define a Generator point, which is just some fixed \"starting point\" on the curve's cycle, which is used to kick off the \"random walk\" around the curve. The generator is a publicly known and agreed upon constant:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Generator IS on the curve:  True\n",
      "Totally random point is not:  False\n"
     ]
    }
   ],
   "source": [
    "@dataclass\n",
    "class Point:\n",
    "    \"\"\" An integer point (x,y) on a Curve \"\"\"\n",
    "    curve: Curve\n",
    "    x: int\n",
    "    y: int\n",
    "\n",
    "G = Point(\n",
    "    bitcoin_curve,\n",
    "    x = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,\n",
    "    y = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8,\n",
    ")\n",
    "\n",
    "# we can verify that the generator point is indeed on the curve, i.e. y^2 = x^3 + 7 (mod p)\n",
    "print(\"Generator IS on the curve: \", (G.y**2 - G.x**3 - 7) % bitcoin_curve.p == 0)\n",
    "\n",
    "# some other totally random point will of course not be on the curve, _MOST_ likely\n",
    "import random\n",
    "random.seed(1337)\n",
    "x = random.randrange(0, bitcoin_curve.p)\n",
    "y = random.randrange(0, bitcoin_curve.p)\n",
    "print(\"Totally random point is not: \", (y**2 - x**3 - 7) % bitcoin_curve.p == 0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, the order of the generating point G is known, and is effectively the \"size of the set\" we are working with in terms of the (x,y) integer tuples on the cycle around the curve. I like to organize this information into one more data structure I'll call Generator:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "@dataclass\n",
    "class Generator:\n",
    "    \"\"\"\n",
    "    A generator over a curve: an initial point and the (pre-computed) order\n",
    "    \"\"\"\n",
    "    G: Point     # a generator point on the curve\n",
    "    n: int       # the order of the generating point, so 0*G = n*G = INF\n",
    "\n",
    "bitcoin_gen = Generator(\n",
    "    G = G,\n",
    "    # the order of G is known and can be mathematically derived\n",
    "    n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Notice that we haven't really done anything so far, it's all just definition of some data structures, and filling them with the publicly known constants related to the elliptic curves used in Bitcoin. This is about to change, as we are ready to generate our private key. The private key (or \"**secret key**\" as I'll call it going forward) is simply a random integer that satisfies 1 <= key < n (recall n is the order of G):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "22265090479312778178772228083027296664144\n"
     ]
    }
   ],
   "source": [
    "# secret_key = random.randrange(1, bitcoin_gen.n) # this is how you _would_ do it\n",
    "secret_key = int.from_bytes(b'Andrej is cool :P', 'big') # this is how I will do it for reproducibility\n",
    "assert 1 <= secret_key < bitcoin_gen.n\n",
    "print(secret_key)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This is our secret key - it is a a pretty unassuming integer but anyone who knows it can control all of the funds you own on the Bitcoin blockchain, associated with it. In the simplest, most common vanilla use case of Bitcoin it is the single \"password\" that controls your account. Of course, in the exceedingly unlikely case that some other Andrej manually generated their secret key as I did above, the wallet associated with this secret key most likely has a balance of zero bitcoin :). If it didn't we'd be very lucky indeed.\n",
    "\n",
    "We are now going to generate the **public key**, which is where things start to get interesting. The public key is the point on the curve that results from adding the generator point to itself secret_key times. i.e. we have: public_key = G + G + G + (secret key times) + G = secret_key * G. Notice that both the '+' (add) and the '\\*' (times) symbol here is very special and slightly confusing. The secret key is an INTEGER, but the generator point G is an (x,y) tuple that is a Point on the Curve, resulting in an (x,y) tuple public key, again a Point on the Curve. This is where we have to actually define the Addition operator on an elliptic curve. It has a very specific definition and a geometric interpretation (see Andrea's post above), but the actual implementation is relatively simple:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "INF = Point(None, None, None) # special point at \"infinity\", kind of like a zero\n",
    "\n",
    "def extended_euclidean_algorithm(a, b):\n",
    "    \"\"\"\n",
    "    Returns (gcd, x, y) s.t. a * x + b * y == gcd\n",
    "    This function implements the extended Euclidean\n",
    "    algorithm and runs in O(log b) in the worst case,\n",
    "    taken from Wikipedia.\n",
    "    \"\"\"\n",
    "    old_r, r = a, b\n",
    "    old_s, s = 1, 0\n",
    "    old_t, t = 0, 1\n",
    "    while r != 0:\n",
    "        quotient = old_r // r\n",
    "        old_r, r = r, old_r - quotient * r\n",
    "        old_s, s = s, old_s - quotient * s\n",
    "        old_t, t = t, old_t - quotient * t\n",
    "    return old_r, old_s, old_t\n",
    "\n",
    "def inv(n, p):\n",
    "    \"\"\" returns modular multiplicate inverse m s.t. (n * m) % p == 1 \"\"\"\n",
    "    gcd, x, y = extended_euclidean_algorithm(n, p) # pylint: disable=unused-variable\n",
    "    return x % p\n",
    "\n",
    "def elliptic_curve_addition(self, other: Point) -> Point:\n",
    "    # handle special case of P + 0 = 0 + P = 0\n",
    "    if self == INF:\n",
    "        return other\n",
    "    if other == INF:\n",
    "        return self\n",
    "    # handle special case of P + (-P) = 0\n",
    "    if self.x == other.x and self.y != other.y:\n",
    "        return INF\n",
    "    # compute the \"slope\"\n",
    "    if self.x == other.x: # (self.y = other.y is guaranteed too per above check)\n",
    "        m = (3 * self.x**2 + self.curve.a) * inv(2 * self.y, self.curve.p)\n",
    "    else:\n",
    "        m = (self.y - other.y) * inv(self.x - other.x, self.curve.p)\n",
    "    # compute the new point\n",
    "    rx = (m**2 - self.x - other.x) % self.curve.p\n",
    "    ry = (-(m*(rx - self.x) + self.y)) % self.curve.p\n",
    "    return Point(self.curve, rx, ry)\n",
    "\n",
    "Point.__add__ = elliptic_curve_addition # monkey patch addition into the Point class"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I admit that it may look a bit scary and understanding and re-deriving the above took me a good half of a day. Most of the complexity comes from all of the math being done with modular arithmetic. So even simple operations like division '/' suddenly require algorithms such as the modular multiplicative inverse `inv`. But the important thing to note is that everything is just a bunch of adds/multiplies over the tuples (x,y) with some modulo p sprinkled everywhere in between. Let's take it for a spin by generating some trivial (private, public) keypairs:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      " secret key: 1\n",
      " public key: (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424)\n",
      "Verify the public key is on the curve:  True\n",
      " secret key: 2\n",
      " public key: (89565891926547004231252920425935692360644145829622209833684329913297188986597, 12158399299693830322967808612713398636155367887041628176798871954788371653930)\n",
      "Verify the public key is on the curve:  True\n",
      " secret key: 3\n",
      " public key: (112711660439710606056748659173929673102114977341539408544630613555209775888121, 25583027980570883691656905877401976406448868254816295069919888960541586679410)\n",
      "Verify the public key is on the curve:  True\n"
     ]
    }
   ],
   "source": [
    "# if our secret key was the interger 1, then our public key would just be G:\n",
    "sk = 1\n",
    "pk = G\n",
    "print(f\" secret key: {sk}\\n public key: {(pk.x, pk.y)}\")\n",
    "print(\"Verify the public key is on the curve: \", (pk.y**2 - pk.x**3 - 7) % bitcoin_curve.p == 0)\n",
    "# if it was 2, the public key is G + G:\n",
    "sk = 2\n",
    "pk = G + G\n",
    "print(f\" secret key: {sk}\\n public key: {(pk.x, pk.y)}\")\n",
    "print(\"Verify the public key is on the curve: \", (pk.y**2 - pk.x**3 - 7) % bitcoin_curve.p == 0)\n",
    "# etc.:\n",
    "sk = 3\n",
    "pk = G + G + G\n",
    "print(f\" secret key: {sk}\\n public key: {(pk.x, pk.y)}\")\n",
    "print(\"Verify the public key is on the curve: \", (pk.y**2 - pk.x**3 - 7) % bitcoin_curve.p == 0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Okay so we have some keypairs above, but we want the public key associated with our randomly generator secret key above. Using just the code above we'd have to add G to itself a very large number of times, because the secret key is a large integer. So the result would be correct but it would run very slow. Instead, let's implement the \"double and add\" algorithm to dramatically speed up the repeated addition. Again, see the post above for why it works, but here it is:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n",
      "True\n",
      "True\n"
     ]
    }
   ],
   "source": [
    "def double_and_add(self, k: int) -> Point:\n",
    "    assert isinstance(k, int) and k >= 0\n",
    "    result = INF\n",
    "    append = self\n",
    "    while k:\n",
    "        if k & 1:\n",
    "            result += append\n",
    "        append += append\n",
    "        k >>= 1\n",
    "    return result\n",
    "\n",
    "# monkey patch double and add into the Point class for convenience\n",
    "Point.__rmul__ = double_and_add\n",
    "\n",
    "# \"verify\" correctness\n",
    "print(G == 1*G)\n",
    "print(G + G == 2*G)\n",
    "print(G + G + G == 3*G)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "x: 83998262154709529558614902604110599582969848537757180553516367057821848015989\n",
      "y: 37676469766173670826348691885774454391218658108212372128812329274086400588247\n",
      "Verify the public key is on the curve:  True\n"
     ]
    }
   ],
   "source": [
    "# efficiently calculate our actual public key!\n",
    "public_key = secret_key * G\n",
    "print(f\"x: {public_key.x}\\ny: {public_key.y}\")\n",
    "print(\"Verify the public key is on the curve: \", (public_key.y**2 - public_key.x**3 - 7) % bitcoin_curve.p == 0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "With the private/public key pair we've now generated our crypto identity. Now it is time to deverive the associated Bitcoin wallet address. The wallet address is not just the public key itself, but it can be deterministically derived from it and has a few extra goodies (such as an embedded checksum). Before we can generate the address though we need to define some hash functions. Bitcoin uses the ubiquitous SHA-256 and also RIPEMD-160. We could just plug and play use the implementations in Python's `hashlib`, but this is supposed to be a zero-dependency implementation, so `import hashlib` is cheating. So first here is the SHA256 implementation I wrote in pure Python following the (relatively readable) NIST [FIPS PUB 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf) doc:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "verify empty hash: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n",
      "69b9779edaa573a509999cbae415d3408c30544bad09727a1d64eff353c95b89\n",
      "number of bytes in a sha256 digest:  32\n"
     ]
    }
   ],
   "source": [
    "def gen_sha256_with_variable_scope_protector_to_not_pollute_global_namespace():\n",
    "    \n",
    "    \"\"\"\n",
    "    SHA256 implementation.\n",
    "    \n",
    "    Follows the FIPS PUB 180-4 description for calculating SHA-256 hash function\n",
    "    https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\n",
    "\n",
    "    Noone in their right mind should use this for any serious reason. This was written\n",
    "    purely for educational purposes.\n",
    "    \"\"\"\n",
    "\n",
    "    import math\n",
    "    from itertools import count, islice\n",
    "\n",
    "    # -----------------------------------------------------------------------------\n",
    "    # SHA-256 Functions, defined in Section 4\n",
    "\n",
    "    def rotr(x, n, size=32):\n",
    "        return (x >> n) | (x << size - n) & (2**size - 1)\n",
    "\n",
    "    def shr(x, n):\n",
    "        return x >> n\n",
    "\n",
    "    def sig0(x):\n",
    "        return rotr(x, 7) ^ rotr(x, 18) ^ shr(x, 3)\n",
    "\n",
    "    def sig1(x):\n",
    "        return rotr(x, 17) ^ rotr(x, 19) ^ shr(x, 10)\n",
    "\n",
    "    def capsig0(x):\n",
    "        return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22)\n",
    "\n",
    "    def capsig1(x):\n",
    "        return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25)\n",
    "\n",
    "    def ch(x, y, z):\n",
    "        return (x & y)^ (~x & z)\n",
    "\n",
    "    def maj(x, y, z):\n",
    "        return (x & y) ^ (x & z) ^ (y & z)\n",
    "\n",
    "    def b2i(b):\n",
    "        return int.from_bytes(b, 'big')\n",
    "\n",
    "    def i2b(i):\n",
    "        return i.to_bytes(4, 'big')\n",
    "\n",
    "    # -----------------------------------------------------------------------------\n",
    "    # SHA-256 Constants\n",
    "\n",
    "    def is_prime(n):\n",
    "        return not any(f for f in range(2,int(math.sqrt(n))+1) if n%f == 0)\n",
    "\n",
    "    def first_n_primes(n):\n",
    "        return islice(filter(is_prime, count(start=2)), n)\n",
    "\n",
    "    def frac_bin(f, n=32):\n",
    "        \"\"\" return the first n bits of fractional part of float f \"\"\"\n",
    "        f -= math.floor(f) # get only the fractional part\n",
    "        f *= 2**n # shift left\n",
    "        f = int(f) # truncate the rest of the fractional content\n",
    "        return f\n",
    "\n",
    "    def genK():\n",
    "        \"\"\"\n",
    "        Follows Section 4.2.2 to generate K\n",
    "\n",
    "        The first 32 bits of the fractional parts of the cube roots of the first\n",
    "        64 prime numbers:\n",
    "\n",
    "        428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5\n",
    "        d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174\n",
    "        e49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da\n",
    "        983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967\n",
    "        27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85\n",
    "        a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070\n",
    "        19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3\n",
    "        748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2\n",
    "        \"\"\"\n",
    "        return [frac_bin(p ** (1/3.0)) for p in first_n_primes(64)]\n",
    "\n",
    "    def genH():\n",
    "        \"\"\"\n",
    "        Follows Section 5.3.3 to generate the initial hash value H^0\n",
    "\n",
    "        The first 32 bits of the fractional parts of the square roots of\n",
    "        the first 8 prime numbers.\n",
    "\n",
    "        6a09e667 bb67ae85 3c6ef372 a54ff53a 9b05688c 510e527f 1f83d9ab 5be0cd19\n",
    "        \"\"\"\n",
    "        return [frac_bin(p ** (1/2.0)) for p in first_n_primes(8)]\n",
    "\n",
    "    # -----------------------------------------------------------------------------\n",
    "\n",
    "    def pad(b):\n",
    "        \"\"\" Follows Section 5.1: Padding the message \"\"\"\n",
    "        b = bytearray(b) # convert to a mutable equivalent\n",
    "        l = len(b) * 8 # note: len returns number of bytes not bits\n",
    "\n",
    "        # append but \"1\" to the end of the message\n",
    "        b.append(0b10000000) # appending 10000000 in binary (=128 in decimal)\n",
    "\n",
    "        # follow by k zero bits, where k is the smallest non-negative solution to\n",
    "        # l + 1 + k = 448 mod 512\n",
    "        # i.e. pad with zeros until we reach 448 (mod 512)\n",
    "        while (len(b)*8) % 512 != 448:\n",
    "            b.append(0x00)\n",
    "\n",
    "        # the last 64-bit block is the length l of the original message\n",
    "        # expressed in binary (big endian)\n",
    "        b.extend(l.to_bytes(8, 'big'))\n",
    "\n",
    "        return b\n",
    "\n",
    "    def sha256(b: bytes) -> bytes:\n",
    "\n",
    "        # Section 4.2\n",
    "        K = genK()\n",
    "\n",
    "        # Section 5: Preprocessing\n",
    "        # Section 5.1: Pad the message\n",
    "        b = pad(b)\n",
    "        # Section 5.2: Separate the message into blocks of 512 bits (64 bytes)\n",
    "        blocks = [b[i:i+64] for i in range(0, len(b), 64)]\n",
    "\n",
    "        # for each message block M^1 ... M^N\n",
    "        H = genH() # Section 5.3\n",
    "\n",
    "        # Section 6\n",
    "        for M in blocks: # each block is a 64-entry array of 8-bit bytes\n",
    "\n",
    "            # 1. Prepare the message schedule, a 64-entry array of 32-bit words\n",
    "            W = []\n",
    "            for t in range(64):\n",
    "                if t <= 15:\n",
    "                    # the first 16 words are just a copy of the block\n",
    "                    W.append(bytes(M[t*4:t*4+4]))\n",
    "                else:\n",
    "                    term1 = sig1(b2i(W[t-2]))\n",
    "                    term2 = b2i(W[t-7])\n",
    "                    term3 = sig0(b2i(W[t-15]))\n",
    "                    term4 = b2i(W[t-16])\n",
    "                    total = (term1 + term2 + term3 + term4) % 2**32\n",
    "                    W.append(i2b(total))\n",
    "\n",
    "            # 2. Initialize the 8 working variables a,b,c,d,e,f,g,h with prev hash value\n",
    "            a, b, c, d, e, f, g, h = H\n",
    "\n",
    "            # 3.\n",
    "            for t in range(64):\n",
    "                T1 = (h + capsig1(e) + ch(e, f, g) + K[t] + b2i(W[t])) % 2**32\n",
    "                T2 = (capsig0(a) + maj(a, b, c)) % 2**32\n",
    "                h = g\n",
    "                g = f\n",
    "                f = e\n",
    "                e = (d + T1) % 2**32\n",
    "                d = c\n",
    "                c = b\n",
    "                b = a\n",
    "                a = (T1 + T2) % 2**32\n",
    "\n",
    "            # 4. Compute the i-th intermediate hash value H^i\n",
    "            delta = [a, b, c, d, e, f, g, h]\n",
    "            H = [(i1 + i2) % 2**32 for i1, i2 in zip(H, delta)]\n",
    "\n",
    "        return b''.join(i2b(i) for i in H)\n",
    "    \n",
    "    return sha256\n",
    "\n",
    "sha256 = gen_sha256_with_variable_scope_protector_to_not_pollute_global_namespace()\n",
    "print(\"verify empty hash:\", sha256(b'').hex()) # should be e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n",
    "print(sha256(b'here is a random bytes message, cool right?').hex())\n",
    "print(\"number of bytes in a sha256 digest: \", len(sha256(b'')))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Okay the reason I wanted to implement this from scratch and paste it here is that I want you to note that again there is nothing too scary going on inside. SHA256 takes some bytes message that is to be hashed, it first pads the message, then breaks it up into chunks, and passes these chunks into what can best be described as a fancy \"bit mixer\", defined in section 3, that contains a number of bit shifts and binary operations orchestrated in a way that is frankly beyond me, but that results in the beautiful properties that SHA256 offers. In particular, it creates a fixed-sized, random-looking short digest of any variably-sized original message s.t. the scrambling is not invertible and also it is basically computationally impossible to construct a different message that hashes to any given digest. \n",
    "\n",
    "Bitcoin uses SHA256 everywhere to create hashes, and of course it is the core element in Bitcoin's Proof of Work, where the goal is to modify the block of transactions until the whole thing hashes to a sufficiently low number (when the bytes of the digest are interpreted as a number). Which, due to the nice properties of SHA256, can only be done via brute force search. So all of the ASICs designed for efficient mining are just incredibly optimized close-to-the-metal implementations of exactly the above code.\n",
    "\n",
    "Anyway before we can generate our address we also need the RIPEMD160 hash function, which I found on the internet and shortened and cleaned up:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "f51960af7dd4813a587ab26388ddab3b28d1f7b4\n",
      "number of bytes in a RIPEMD-160 digest:  20\n"
     ]
    }
   ],
   "source": [
    "def gen_ripemd160_with_variable_scope_protector_to_not_pollute_global_namespace():\n",
    "\n",
    "    import sys\n",
    "    import struct\n",
    "\n",
    "    # -----------------------------------------------------------------------------\n",
    "    # public interface\n",
    "\n",
    "    def ripemd160(b: bytes) -> bytes:\n",
    "        \"\"\" simple wrapper for a simpler API to this hash function, just bytes to bytes \"\"\"\n",
    "        ctx = RMDContext()\n",
    "        RMD160Update(ctx, b, len(b))\n",
    "        digest = RMD160Final(ctx)\n",
    "        return digest\n",
    "\n",
    "    # -----------------------------------------------------------------------------\n",
    "\n",
    "    class RMDContext:\n",
    "        def __init__(self):\n",
    "            self.state = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0] # uint32\n",
    "            self.count = 0 # uint64\n",
    "            self.buffer = [0]*64 # uchar\n",
    "\n",
    "    def RMD160Update(ctx, inp, inplen):\n",
    "        have = int((ctx.count // 8) % 64)\n",
    "        inplen = int(inplen)\n",
    "        need = 64 - have\n",
    "        ctx.count += 8 * inplen\n",
    "        off = 0\n",
    "        if inplen >= need:\n",
    "            if have:\n",
    "                for i in range(need):\n",
    "                    ctx.buffer[have+i] = inp[i]\n",
    "                RMD160Transform(ctx.state, ctx.buffer)\n",
    "                off = need\n",
    "                have = 0\n",
    "            while off + 64 <= inplen:\n",
    "                RMD160Transform(ctx.state, inp[off:])\n",
    "                off += 64\n",
    "        if off < inplen:\n",
    "            for i in range(inplen - off):\n",
    "                ctx.buffer[have+i] = inp[off+i]\n",
    "\n",
    "    def RMD160Final(ctx):\n",
    "        size = struct.pack(\"<Q\", ctx.count)\n",
    "        padlen = 64 - ((ctx.count // 8) % 64)\n",
    "        if padlen < 1 + 8:\n",
    "            padlen += 64\n",
    "        RMD160Update(ctx, PADDING, padlen-8)\n",
    "        RMD160Update(ctx, size, 8)\n",
    "        return struct.pack(\"<5L\", *ctx.state)\n",
    "\n",
    "    # -----------------------------------------------------------------------------\n",
    "\n",
    "    K0 = 0x00000000\n",
    "    K1 = 0x5A827999\n",
    "    K2 = 0x6ED9EBA1\n",
    "    K3 = 0x8F1BBCDC\n",
    "    K4 = 0xA953FD4E\n",
    "    KK0 = 0x50A28BE6\n",
    "    KK1 = 0x5C4DD124\n",
    "    KK2 = 0x6D703EF3\n",
    "    KK3 = 0x7A6D76E9\n",
    "    KK4 = 0x00000000\n",
    "\n",
    "    PADDING = [0x80] + [0]*63\n",
    "\n",
    "    def ROL(n, x):\n",
    "        return ((x << n) & 0xffffffff) | (x >> (32 - n))\n",
    "\n",
    "    def F0(x, y, z):\n",
    "        return x ^ y ^ z\n",
    "\n",
    "    def F1(x, y, z):\n",
    "        return (x & y) | (((~x) % 0x100000000) & z)\n",
    "\n",
    "    def F2(x, y, z):\n",
    "        return (x | ((~y) % 0x100000000)) ^ z\n",
    "\n",
    "    def F3(x, y, z):\n",
    "        return (x & z) | (((~z) % 0x100000000) & y)\n",
    "\n",
    "    def F4(x, y, z):\n",
    "        return x ^ (y | ((~z) % 0x100000000))\n",
    "\n",
    "    def R(a, b, c, d, e, Fj, Kj, sj, rj, X):\n",
    "        a = ROL(sj, (a + Fj(b, c, d) + X[rj] + Kj) % 0x100000000) + e\n",
    "        c = ROL(10, c)\n",
    "        return a % 0x100000000, c\n",
    "\n",
    "    def RMD160Transform(state, block): #uint32 state[5], uchar block[64]\n",
    "\n",
    "        x = [0]*16\n",
    "        assert sys.byteorder == 'little', \"Only little endian is supported atm for RIPEMD160\"\n",
    "        x = struct.unpack('<16L', bytes(block[0:64]))\n",
    "\n",
    "        a = state[0]\n",
    "        b = state[1]\n",
    "        c = state[2]\n",
    "        d = state[3]\n",
    "        e = state[4]\n",
    "\n",
    "        #/* Round 1 */\n",
    "        a, c = R(a, b, c, d, e, F0, K0, 11,  0, x)\n",
    "        e, b = R(e, a, b, c, d, F0, K0, 14,  1, x)\n",
    "        d, a = R(d, e, a, b, c, F0, K0, 15,  2, x)\n",
    "        c, e = R(c, d, e, a, b, F0, K0, 12,  3, x)\n",
    "        b, d = R(b, c, d, e, a, F0, K0,  5,  4, x)\n",
    "        a, c = R(a, b, c, d, e, F0, K0,  8,  5, x)\n",
    "        e, b = R(e, a, b, c, d, F0, K0,  7,  6, x)\n",
    "        d, a = R(d, e, a, b, c, F0, K0,  9,  7, x)\n",
    "        c, e = R(c, d, e, a, b, F0, K0, 11,  8, x)\n",
    "        b, d = R(b, c, d, e, a, F0, K0, 13,  9, x)\n",
    "        a, c = R(a, b, c, d, e, F0, K0, 14, 10, x)\n",
    "        e, b = R(e, a, b, c, d, F0, K0, 15, 11, x)\n",
    "        d, a = R(d, e, a, b, c, F0, K0,  6, 12, x)\n",
    "        c, e = R(c, d, e, a, b, F0, K0,  7, 13, x)\n",
    "        b, d = R(b, c, d, e, a, F0, K0,  9, 14, x)\n",
    "        a, c = R(a, b, c, d, e, F0, K0,  8, 15, x) #/* #15 */\n",
    "        #/* Round 2 */\n",
    "        e, b = R(e, a, b, c, d, F1, K1,  7,  7, x)\n",
    "        d, a = R(d, e, a, b, c, F1, K1,  6,  4, x)\n",
    "        c, e = R(c, d, e, a, b, F1, K1,  8, 13, x)\n",
    "        b, d = R(b, c, d, e, a, F1, K1, 13,  1, x)\n",
    "        a, c = R(a, b, c, d, e, F1, K1, 11, 10, x)\n",
    "        e, b = R(e, a, b, c, d, F1, K1,  9,  6, x)\n",
    "        d, a = R(d, e, a, b, c, F1, K1,  7, 15, x)\n",
    "        c, e = R(c, d, e, a, b, F1, K1, 15,  3, x)\n",
    "        b, d = R(b, c, d, e, a, F1, K1,  7, 12, x)\n",
    "        a, c = R(a, b, c, d, e, F1, K1, 12,  0, x)\n",
    "        e, b = R(e, a, b, c, d, F1, K1, 15,  9, x)\n",
    "        d, a = R(d, e, a, b, c, F1, K1,  9,  5, x)\n",
    "        c, e = R(c, d, e, a, b, F1, K1, 11,  2, x)\n",
    "        b, d = R(b, c, d, e, a, F1, K1,  7, 14, x)\n",
    "        a, c = R(a, b, c, d, e, F1, K1, 13, 11, x)\n",
    "        e, b = R(e, a, b, c, d, F1, K1, 12,  8, x) #/* #31 */\n",
    "        #/* Round 3 */\n",
    "        d, a = R(d, e, a, b, c, F2, K2, 11,  3, x)\n",
    "        c, e = R(c, d, e, a, b, F2, K2, 13, 10, x)\n",
    "        b, d = R(b, c, d, e, a, F2, K2,  6, 14, x)\n",
    "        a, c = R(a, b, c, d, e, F2, K2,  7,  4, x)\n",
    "        e, b = R(e, a, b, c, d, F2, K2, 14,  9, x)\n",
    "        d, a = R(d, e, a, b, c, F2, K2,  9, 15, x)\n",
    "        c, e = R(c, d, e, a, b, F2, K2, 13,  8, x)\n",
    "        b, d = R(b, c, d, e, a, F2, K2, 15,  1, x)\n",
    "        a, c = R(a, b, c, d, e, F2, K2, 14,  2, x)\n",
    "        e, b = R(e, a, b, c, d, F2, K2,  8,  7, x)\n",
    "        d, a = R(d, e, a, b, c, F2, K2, 13,  0, x)\n",
    "        c, e = R(c, d, e, a, b, F2, K2,  6,  6, x)\n",
    "        b, d = R(b, c, d, e, a, F2, K2,  5, 13, x)\n",
    "        a, c = R(a, b, c, d, e, F2, K2, 12, 11, x)\n",
    "        e, b = R(e, a, b, c, d, F2, K2,  7,  5, x)\n",
    "        d, a = R(d, e, a, b, c, F2, K2,  5, 12, x) #/* #47 */\n",
    "        #/* Round 4 */\n",
    "        c, e = R(c, d, e, a, b, F3, K3, 11,  1, x)\n",
    "        b, d = R(b, c, d, e, a, F3, K3, 12,  9, x)\n",
    "        a, c = R(a, b, c, d, e, F3, K3, 14, 11, x)\n",
    "        e, b = R(e, a, b, c, d, F3, K3, 15, 10, x)\n",
    "        d, a = R(d, e, a, b, c, F3, K3, 14,  0, x)\n",
    "        c, e = R(c, d, e, a, b, F3, K3, 15,  8, x)\n",
    "        b, d = R(b, c, d, e, a, F3, K3,  9, 12, x)\n",
    "        a, c = R(a, b, c, d, e, F3, K3,  8,  4, x)\n",
    "        e, b = R(e, a, b, c, d, F3, K3,  9, 13, x)\n",
    "        d, a = R(d, e, a, b, c, F3, K3, 14,  3, x)\n",
    "        c, e = R(c, d, e, a, b, F3, K3,  5,  7, x)\n",
    "        b, d = R(b, c, d, e, a, F3, K3,  6, 15, x)\n",
    "        a, c = R(a, b, c, d, e, F3, K3,  8, 14, x)\n",
    "        e, b = R(e, a, b, c, d, F3, K3,  6,  5, x)\n",
    "        d, a = R(d, e, a, b, c, F3, K3,  5,  6, x)\n",
    "        c, e = R(c, d, e, a, b, F3, K3, 12,  2, x) #/* #63 */\n",
    "        #/* Round 5 */\n",
    "        b, d = R(b, c, d, e, a, F4, K4,  9,  4, x)\n",
    "        a, c = R(a, b, c, d, e, F4, K4, 15,  0, x)\n",
    "        e, b = R(e, a, b, c, d, F4, K4,  5,  5, x)\n",
    "        d, a = R(d, e, a, b, c, F4, K4, 11,  9, x)\n",
    "        c, e = R(c, d, e, a, b, F4, K4,  6,  7, x)\n",
    "        b, d = R(b, c, d, e, a, F4, K4,  8, 12, x)\n",
    "        a, c = R(a, b, c, d, e, F4, K4, 13,  2, x)\n",
    "        e, b = R(e, a, b, c, d, F4, K4, 12, 10, x)\n",
    "        d, a = R(d, e, a, b, c, F4, K4,  5, 14, x)\n",
    "        c, e = R(c, d, e, a, b, F4, K4, 12,  1, x)\n",
    "        b, d = R(b, c, d, e, a, F4, K4, 13,  3, x)\n",
    "        a, c = R(a, b, c, d, e, F4, K4, 14,  8, x)\n",
    "        e, b = R(e, a, b, c, d, F4, K4, 11, 11, x)\n",
    "        d, a = R(d, e, a, b, c, F4, K4,  8,  6, x)\n",
    "        c, e = R(c, d, e, a, b, F4, K4,  5, 15, x)\n",
    "        b, d = R(b, c, d, e, a, F4, K4,  6, 13, x) #/* #79 */\n",
    "\n",
    "        aa = a\n",
    "        bb = b\n",
    "        cc = c\n",
    "        dd = d\n",
    "        ee = e\n",
    "\n",
    "        a = state[0]\n",
    "        b = state[1]\n",
    "        c = state[2]\n",
    "        d = state[3]\n",
    "        e = state[4]\n",
    "\n",
    "        #/* Parallel round 1 */\n",
    "        a, c = R(a, b, c, d, e, F4, KK0,  8,  5, x)\n",
    "        e, b = R(e, a, b, c, d, F4, KK0,  9, 14, x)\n",
    "        d, a = R(d, e, a, b, c, F4, KK0,  9,  7, x)\n",
    "        c, e = R(c, d, e, a, b, F4, KK0, 11,  0, x)\n",
    "        b, d = R(b, c, d, e, a, F4, KK0, 13,  9, x)\n",
    "        a, c = R(a, b, c, d, e, F4, KK0, 15,  2, x)\n",
    "        e, b = R(e, a, b, c, d, F4, KK0, 15, 11, x)\n",
    "        d, a = R(d, e, a, b, c, F4, KK0,  5,  4, x)\n",
    "        c, e = R(c, d, e, a, b, F4, KK0,  7, 13, x)\n",
    "        b, d = R(b, c, d, e, a, F4, KK0,  7,  6, x)\n",
    "        a, c = R(a, b, c, d, e, F4, KK0,  8, 15, x)\n",
    "        e, b = R(e, a, b, c, d, F4, KK0, 11,  8, x)\n",
    "        d, a = R(d, e, a, b, c, F4, KK0, 14,  1, x)\n",
    "        c, e = R(c, d, e, a, b, F4, KK0, 14, 10, x)\n",
    "        b, d = R(b, c, d, e, a, F4, KK0, 12,  3, x)\n",
    "        a, c = R(a, b, c, d, e, F4, KK0,  6, 12, x) #/* #15 */\n",
    "        #/* Parallel round 2 */\n",
    "        e, b = R(e, a, b, c, d, F3, KK1,  9,  6, x)\n",
    "        d, a = R(d, e, a, b, c, F3, KK1, 13, 11, x)\n",
    "        c, e = R(c, d, e, a, b, F3, KK1, 15,  3, x)\n",
    "        b, d = R(b, c, d, e, a, F3, KK1,  7,  7, x)\n",
    "        a, c = R(a, b, c, d, e, F3, KK1, 12,  0, x)\n",
    "        e, b = R(e, a, b, c, d, F3, KK1,  8, 13, x)\n",
    "        d, a = R(d, e, a, b, c, F3, KK1,  9,  5, x)\n",
    "        c, e = R(c, d, e, a, b, F3, KK1, 11, 10, x)\n",
    "        b, d = R(b, c, d, e, a, F3, KK1,  7, 14, x)\n",
    "        a, c = R(a, b, c, d, e, F3, KK1,  7, 15, x)\n",
    "        e, b = R(e, a, b, c, d, F3, KK1, 12,  8, x)\n",
    "        d, a = R(d, e, a, b, c, F3, KK1,  7, 12, x)\n",
    "        c, e = R(c, d, e, a, b, F3, KK1,  6,  4, x)\n",
    "        b, d = R(b, c, d, e, a, F3, KK1, 15,  9, x)\n",
    "        a, c = R(a, b, c, d, e, F3, KK1, 13,  1, x)\n",
    "        e, b = R(e, a, b, c, d, F3, KK1, 11,  2, x) #/* #31 */\n",
    "        #/* Parallel round 3 */\n",
    "        d, a = R(d, e, a, b, c, F2, KK2,  9, 15, x)\n",
    "        c, e = R(c, d, e, a, b, F2, KK2,  7,  5, x)\n",
    "        b, d = R(b, c, d, e, a, F2, KK2, 15,  1, x)\n",
    "        a, c = R(a, b, c, d, e, F2, KK2, 11,  3, x)\n",
    "        e, b = R(e, a, b, c, d, F2, KK2,  8,  7, x)\n",
    "        d, a = R(d, e, a, b, c, F2, KK2,  6, 14, x)\n",
    "        c, e = R(c, d, e, a, b, F2, KK2,  6,  6, x)\n",
    "        b, d = R(b, c, d, e, a, F2, KK2, 14,  9, x)\n",
    "        a, c = R(a, b, c, d, e, F2, KK2, 12, 11, x)\n",
    "        e, b = R(e, a, b, c, d, F2, KK2, 13,  8, x)\n",
    "        d, a = R(d, e, a, b, c, F2, KK2,  5, 12, x)\n",
    "        c, e = R(c, d, e, a, b, F2, KK2, 14,  2, x)\n",
    "        b, d = R(b, c, d, e, a, F2, KK2, 13, 10, x)\n",
    "        a, c = R(a, b, c, d, e, F2, KK2, 13,  0, x)\n",
    "        e, b = R(e, a, b, c, d, F2, KK2,  7,  4, x)\n",
    "        d, a = R(d, e, a, b, c, F2, KK2,  5, 13, x) #/* #47 */\n",
    "        #/* Parallel round 4 */\n",
    "        c, e = R(c, d, e, a, b, F1, KK3, 15,  8, x)\n",
    "        b, d = R(b, c, d, e, a, F1, KK3,  5,  6, x)\n",
    "        a, c = R(a, b, c, d, e, F1, KK3,  8,  4, x)\n",
    "        e, b = R(e, a, b, c, d, F1, KK3, 11,  1, x)\n",
    "        d, a = R(d, e, a, b, c, F1, KK3, 14,  3, x)\n",
    "        c, e = R(c, d, e, a, b, F1, KK3, 14, 11, x)\n",
    "        b, d = R(b, c, d, e, a, F1, KK3,  6, 15, x)\n",
    "        a, c = R(a, b, c, d, e, F1, KK3, 14,  0, x)\n",
    "        e, b = R(e, a, b, c, d, F1, KK3,  6,  5, x)\n",
    "        d, a = R(d, e, a, b, c, F1, KK3,  9, 12, x)\n",
    "        c, e = R(c, d, e, a, b, F1, KK3, 12,  2, x)\n",
    "        b, d = R(b, c, d, e, a, F1, KK3,  9, 13, x)\n",
    "        a, c = R(a, b, c, d, e, F1, KK3, 12,  9, x)\n",
    "        e, b = R(e, a, b, c, d, F1, KK3,  5,  7, x)\n",
    "        d, a = R(d, e, a, b, c, F1, KK3, 15, 10, x)\n",
    "        c, e = R(c, d, e, a, b, F1, KK3,  8, 14, x) #/* #63 */\n",
    "        #/* Parallel round 5 */\n",
    "        b, d = R(b, c, d, e, a, F0, KK4,  8, 12, x)\n",
    "        a, c = R(a, b, c, d, e, F0, KK4,  5, 15, x)\n",
    "        e, b = R(e, a, b, c, d, F0, KK4, 12, 10, x)\n",
    "        d, a = R(d, e, a, b, c, F0, KK4,  9,  4, x)\n",
    "        c, e = R(c, d, e, a, b, F0, KK4, 12,  1, x)\n",
    "        b, d = R(b, c, d, e, a, F0, KK4,  5,  5, x)\n",
    "        a, c = R(a, b, c, d, e, F0, KK4, 14,  8, x)\n",
    "        e, b = R(e, a, b, c, d, F0, KK4,  6,  7, x)\n",
    "        d, a = R(d, e, a, b, c, F0, KK4,  8,  6, x)\n",
    "        c, e = R(c, d, e, a, b, F0, KK4, 13,  2, x)\n",
    "        b, d = R(b, c, d, e, a, F0, KK4,  6, 13, x)\n",
    "        a, c = R(a, b, c, d, e, F0, KK4,  5, 14, x)\n",
    "        e, b = R(e, a, b, c, d, F0, KK4, 15,  0, x)\n",
    "        d, a = R(d, e, a, b, c, F0, KK4, 13,  3, x)\n",
    "        c, e = R(c, d, e, a, b, F0, KK4, 11,  9, x)\n",
    "        b, d = R(b, c, d, e, a, F0, KK4, 11, 11, x) #/* #79 */\n",
    "\n",
    "        t = (state[1] + cc + d) % 0x100000000\n",
    "        state[1] = (state[2] + dd + e) % 0x100000000\n",
    "        state[2] = (state[3] + ee + a) % 0x100000000\n",
    "        state[3] = (state[4] + aa + b) % 0x100000000\n",
    "        state[4] = (state[0] + bb + c) % 0x100000000\n",
    "        state[0] = t % 0x100000000\n",
    "    \n",
    "    return ripemd160\n",
    "    \n",
    "ripemd160 = gen_ripemd160_with_variable_scope_protector_to_not_pollute_global_namespace()\n",
    "print(ripemd160(b'hello this is a test').hex())\n",
    "print(\"number of bytes in a RIPEMD-160 digest: \", len(ripemd160(b'')))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As with SHA256 above, again we see a \"bit scrambler\" of a lot of binary ops. Pretty cool. \n",
    "\n",
    "Okay we are finally ready to get our Bitcoin address. We are going to make this nice by creating a subclass of `Point` called `PublicKey` which is, again, just a Point on the Curve but now has some additional semantics and interpretation of a Bitcoin public key, together with some methods of encoding/decoding the key into bytes for communication in the Bitcoin protocol.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class PublicKey(Point):\n",
    "    \"\"\"\n",
    "    The public key is just a Point on a Curve, but has some additional specific\n",
    "    encoding / decoding functionality that this class implements.\n",
    "    \"\"\"\n",
    "\n",
    "    @classmethod\n",
    "    def from_point(cls, pt: Point):\n",
    "        \"\"\" promote a Point to be a PublicKey \"\"\"\n",
    "        return cls(pt.curve, pt.x, pt.y)\n",
    "\n",
    "    def encode(self, compressed, hash160=False):\n",
    "        \"\"\" return the SEC bytes encoding of the public key Point \"\"\"\n",
    "        # calculate the bytes\n",
    "        if compressed:\n",
    "            # (x,y) is very redundant. Because y^2 = x^3 + 7,\n",
    "            # we can just encode x, and then y = +/- sqrt(x^3 + 7),\n",
    "            # so we need one more bit to encode whether it was the + or the -\n",
    "            # but because this is modular arithmetic there is no +/-, instead\n",
    "            # it can be shown that one y will always be even and the other odd.\n",
    "            prefix = b'\\x02' if self.y % 2 == 0 else b'\\x03'\n",
    "            pkb = prefix + self.x.to_bytes(32, 'big')\n",
    "        else:\n",
    "            pkb = b'\\x04' + self.x.to_bytes(32, 'big') + self.y.to_bytes(32, 'big')\n",
    "        # hash if desired\n",
    "        return ripemd160(sha256(pkb)) if hash160 else pkb\n",
    "\n",
    "    def address(self, net: str, compressed: bool) -> str:\n",
    "        \"\"\" return the associated bitcoin address for this public key as string \"\"\"\n",
    "        # encode the public key into bytes and hash to get the payload\n",
    "        pkb_hash = self.encode(compressed=compressed, hash160=True)\n",
    "        # add version byte (0x00 for Main Network, or 0x6f for Test Network)\n",
    "        version = {'main': b'\\x00', 'test': b'\\x6f'}\n",
    "        ver_pkb_hash = version[net] + pkb_hash\n",
    "        # calculate the checksum\n",
    "        checksum = sha256(sha256(ver_pkb_hash))[:4]\n",
    "        # append to form the full 25-byte binary Bitcoin Address\n",
    "        byte_address = ver_pkb_hash + checksum\n",
    "        # finally b58 encode the result\n",
    "        b58check_address = b58encode(byte_address)\n",
    "        return b58check_address\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We are not yet ready to take this class for a spin because you'll note there is one more necessary dependency here, which is the b58 encoding function `b58encode`. This is just a Bitcoin-specific encoding of bytes that uses base 58, of characters of the alphabet that are very unambiguous. For example it does not use 'O' and '0', because they are very easy to mess up on paper. So we have to take our Bitcoin address (which is 25 bytes in its raw form) and convert it to base 58 and print out the characters. The raw 25 bytes of our address though contain 1 byte for a Version (the Bitcoin \"main net\" is `b'\\x00'`, while the Bitcoin \"test net\" uses `b'\\x6f'`), then the 20 bytes from the hash digest, and finally 4 bytes for a checksum so we can throw an error with `1 - 1/2**4 = 93.75%` probability in case a user messes up typing in their Bitcoin address into some textbox. So here is the b58 encoding:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "# base58 encoding / decoding utilities\n",
    "# reference: https://en.bitcoin.it/wiki/Base58Check_encoding\n",
    "\n",
    "alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n",
    "\n",
    "def b58encode(b: bytes) -> str:\n",
    "    assert len(b) == 25 # version is 1 byte, pkb_hash 20 bytes, checksum 4 bytes\n",
    "    n = int.from_bytes(b, 'big')\n",
    "    chars = []\n",
    "    while n:\n",
    "        n, i = divmod(n, 58)\n",
    "        chars.append(alphabet[i])\n",
    "    # special case handle the leading 0 bytes... ¯\\_(ツ)_/¯\n",
    "    num_leading_zeros = len(b) - len(b.lstrip(b'\\x00'))\n",
    "    res = num_leading_zeros * alphabet[0] + ''.join(reversed(chars))\n",
    "    return res\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's now print our Bitcoin address:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "mnNcaVkC35ezZSgvn8fhXEa9QTHSUtPfzQ\n"
     ]
    }
   ],
   "source": [
    "# we are going to use the develop's Bitcoin parallel universe \"test net\" for this demo, so net='test'\n",
    "address = PublicKey.from_point(public_key).address(net='test', compressed=True)\n",
    "print(address)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Cool, we can now check some block explorer website to verify that this address has never transacted before:\n",
    "[https://www.blockchain.com/btc-testnet/address/mnNcaVkC35ezZSgvn8fhXEa9QTHSUtPfzQ](https://www.blockchain.com/btc-testnet/address/mnNcaVkC35ezZSgvn8fhXEa9QTHSUtPfzQ). By the end of this tutorial it won't be, but at the time of writing indeed I saw that this address is \"clean\", so noone has generated and used the secret key on the testnet so far like we did up above. Which makes sense because there would have to be some other \"Andrej\" with a bad sense of humor also tinkering with Bitcoin. But we can also check some super non-secret secret keys, which we expect would have been used be people in the past. For example we can check the address belonging to the lowest valid secret key of 1, where the public key is exactly the generator point :). Here's how we get it:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'mrCDrCybB6J1vRfbwM5hemdJz73FwDBC8r'"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lol_secret_key = 1\n",
    "lol_public_key = lol_secret_key * G\n",
    "lol_address = PublicKey.from_point(lol_public_key).address(net='test', compressed=True)\n",
    "lol_address"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Indeed, as we [see](https://www.blockchain.com/btc-testnet/address/mrCDrCybB6J1vRfbwM5hemdJz73FwDBC8r) on the blockchain explorer that this address has transacted 1,812 times at the time of writing and has a balance of $0.00 BTC. This makes sense because if it did have any balance (in the naive case, modulo some subtleties with the scripting language we'll go into) then anyone would just be able to spend it because they know secret key (1) and can use it to digitally sign transactions that spend it. We'll see how that works shortly.\n",
    "\n",
    "#### Part 1: Summary so far\n",
    "\n",
    "We are able to generate a crypto identity that consists of a secret key (a random integer) that only we know, and a derived public key by jumping around the Elliptic curve using scalar multiplication of the Generating point on the Bitcoin elliptic curve. We then also derived the associated Bitcoin address which we can share with others to ask for moneys, and doing so involved the introduction of two hash functions (SHA256 and RIPEMD160). Here are the three important quantities summarized and printed out again:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Our first Bitcoin identity:\n",
      "1. secret key:  22265090479312778178772228083027296664144\n",
      "2. public key:  (83998262154709529558614902604110599582969848537757180553516367057821848015989, 37676469766173670826348691885774454391218658108212372128812329274086400588247)\n",
      "3. Bitcoin address:  mnNcaVkC35ezZSgvn8fhXEa9QTHSUtPfzQ\n"
     ]
    }
   ],
   "source": [
    "print(\"Our first Bitcoin identity:\")\n",
    "print(\"1. secret key: \", secret_key)\n",
    "print(\"2. public key: \", (public_key.x, public_key.y))\n",
    "print(\"3. Bitcoin address: \", address)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Part 2: Obtaining seed funds + intro to Bitcoin under the hood\n",
    "\n",
    "It is now time to create a transaction. We are going to be sending some BTC from the address we generated above (mnNcaVkC35ezZSgvn8fhXEa9QTHSUtPfzQ) to some second wallet we control. Let's create this second \"target\" wallet now:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Our second Bitcoin identity:\n",
      "1. secret key:  29595381593786747354608258168471648998894101022644411052850960746671046944116\n",
      "2. public key:  (70010837237584666034852528437623689803658776589997047576978119215393051139210, 35910266550486169026860404782843121421687961955681935571785539885177648410329)\n",
      "3. Bitcoin address:  mrFF91kpuRbivucowsY512fDnYt6BWrvx9\n"
     ]
    }
   ],
   "source": [
    "secret_key2 = int.from_bytes(b\"Andrej's Super Secret 2nd Wallet\", 'big') # or just random.randrange(1, bitcoin_gen.n)\n",
    "assert 1 <= secret_key2 < bitcoin_gen.n # check it's valid\n",
    "public_key2 = secret_key2 * G\n",
    "address2 = PublicKey.from_point(public_key2).address(net='test', compressed=True)\n",
    "\n",
    "print(\"Our second Bitcoin identity:\")\n",
    "print(\"1. secret key: \", secret_key2)\n",
    "print(\"2. public key: \", (public_key2.x, public_key2.y))\n",
    "print(\"3. Bitcoin address: \", address2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Ok great so our goal is to send some BTC from mnNcaVkC35ezZSgvn8fhXEa9QTHSUtPfzQ to mrFF91kpuRbivucowsY512fDnYt6BWrvx9. First, because we just generated these identities from scratch, the first address has no bitcoin on it. Because we are using the \"parallel universe\" developer-intended Bitcoin test network, we can use one of multiple available faucets to pretty please request some BTC. I did this by Googling \"bitcoin testnet faucet\", hitting the first link, and asking the faucet to send some bitcoins to our source address  mnNcaVkC35ezZSgvn8fhXEa9QTHSUtPfzQ. A few minutes later, we can go back to the blockchain explorer and see that we [received the coins](https://www.blockchain.com/btc-testnet/address/mnNcaVkC35ezZSgvn8fhXEa9QTHSUtPfzQ), in this case 0.001 BTC. Faucets are available for the test net, but of course you won't find them on the main net :) You'd have to e.g. open up a Coinbase account (which generates a wallet) and buy some BTC for USD. In this tutorial we'll be working on the test net, but everything we do would work just fine on the main net as well.\n",
    "\n",
    "Now if we click on the exact [transaction ID](https://www.blockchain.com/btc-testnet/tx/46325085c89fb98a4b7ceee44eac9b955f09e1ddc86d8dad3dfdcba46b4d36b2) we can see a bunch of additional information that gets to the heart of Bitcoin and how money is represented in it.\n",
    "\n",
    "**Transaction id**. First note that every transaction has a distinct id / hash. In this case the faucet transaction has id 46325085c89fb98a4b7ceee44eac9b955f09e1ddc86d8dad3dfdcba46b4d36b2. As we'll see, this is just a SHA256 double hash (hash of a hash) of the transaction data structure that we'll see soon serialized into bytes. Double SHA256 hashes are often used in place of a single hash in Bitcoin for added security, to mitigate a [few shortcomings](https://en.wikipedia.org/wiki/SHA-2#Comparison_of_SHA_functions) of just one round of SHA256, and some related attacks discovered on the older version of SHA (SHA-1).\n",
    "\n",
    "**Inputs and Outputs**. We see that the faucet transaction has 1 input and 2 outputs. The 1 input came from address \n",
    "2MwjXCY7RRpo8MYjtsJtP5erNirzFB9MtnH of value 0.17394181 BTC. There were 2 outputs. The second output was our address and we received exactly 0.001 BTC. The first output is some different, unknown address 2NCorZJ6XfdimrFQuwWjcJhQJDxPqjNgLzG which received 0.17294013 BTC, and is presumably controlled by the faucet owners. Notice that the the inputs don't exactly add up to the outputs. Indeed we have that `0.17394181 - (0.001 + 0.17294013) = 0.00000168`. This \"change\" amount is called the fee, and this fee is allowed to claimed by the Bitcoin miner who has included this transaction in their block, which in this case was [Block 2005500](https://www.blockchain.com/btc-testnet/block/2005500). You can see that this block had 48 transactions, and the faucet transaction was one of them! Now, the fee acts as a financial incetive for miners to include the transaction in their block, because they get to keep the change. The higher the fee to the miner, the more likely and faster the transaction is to appear in the blockchain. With a high fee we'd expect it to be eagerly taken up by miners and included in the very next block. With a low fee the transaction might never be included, because there are many other transactions broadcasted in the network that are willing to pay a higher fee. So if you're a miner and you have a finite amount of space to put into your Block - why bother? \n",
    "\n",
    "When we make our own transaction, we'll have to make sure to include this tip for the miner, and pay \"market rate\", which we'll look up. In the case of this block, we can see that the total amount of BTC made by the miner of this block was 0.09765625 BTC from the special \"Coinbase\" transaction, that each miner is allowed to send from a null input to themselves, and then a total of 0.00316119 BTC was the total fee reward, summed up over all of the 47 non-Coinbase transactions in this block.\n",
    "\n",
    "**Size**. Also note that this transaction (serialized) was 249 bytes. This is a pretty average size for a simple transaction like this.\n",
    "\n",
    "**Pkscript**. Lastly note that the second Output (our 0.001 BTC) when you scroll down to its details has a \"Pkscript\" field, which shows:\n",
    "\n",
    "```\n",
    "OP_DUP\n",
    "OP_HASH160\n",
    "4b3518229b0d3554fe7cd3796ade632aff3069d8\n",
    "OP_EQUALVERIFY\n",
    "OP_CHECKSIG\n",
    "```\n",
    "\n",
    "This is where things get a bit crazy with Bitcoin. It has a whole stack-based scripting language, but unless you're doing crazy multisig smart contract triple escrow backflips (?), the vast majority of transactions use one of very few simple \"special case\" scripts, just like the one here. By now my eyes just glaze over it as the standard simple thing. This \"Pkscript\" is the \"locking script\" for this specific Output, which holds 0.001 BTC in it. We are going to want to spend this Output and turn it into an Input in our upcoming transaction. In order to unlock this output we are going to have to satisfy the conditions of this locking script. In English, this script is saying that any Transaction that aspires to spend this Output must satisfy two conditions. 1) their Public key better hash to 4b3518229b0d3554fe7cd3796ade632aff3069d8. And 2) the digital signature for the aspiring transaction better validate as being generated by this public key's associated private key. Only the owner of the secret key will be able to both 1) provide the full public key, which will be checked to hash correctly, and 2) create the digital signature, as we'll soon see.\n",
    "\n",
    "By the way, we can verify that of course our public key hashes correctly, so we'll be able to include it in our upcoming transaction, and the all of the mining nodes will be able to verify condition (1). Very early Bitcoin transactions had locking scripts that directly contained the public key (instead of its hash) followed by OP_CHECKSIG, but doing it in this slightly more complex way protects the exact public key behind the hash, until the owner wants to spend the funds, only then do they reveal the public key. (If you'd like to learn more look up p2pk vs p2pkh transactions)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'4b3518229b0d3554fe7cd3796ade632aff3069d8'"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "PublicKey.from_point(public_key).encode(compressed=True, hash160=True).hex()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Part 3: Crafting our transaction\n",
    "\n",
    "Okay, now we're going to actually craft our transaction. Let's say that we want to send half of our funds to our second wallet. i.e. we currently have a wallet with 0.001 BTC, and we'd like to send 0.0005 BTC to our second wallet. To achieve this our transaction will have exactly one input (= 2nd output of the faucet transaction), and exactly 2 outputs. One output will go to our 2nd address, and the rest of it we will send back to our own address!\n",
    "\n",
    "This here is a critical part to understand. It's a bit funky. Every Input/Output of any bitcoin transaction must always be fully spent. So if we own 0.001 BTC and want to send half of it somewhere else, we actually have to send one half there, and one half back to us.\n",
    "\n",
    "The Transaction will be considered valid if the sum of all outputs is lower than the sum of all inputs (so we're not minting money). The remainder will be the \"change\" (fee) that will be claimed by the winning miner who lucks out on the proof of work, and includes our transaction in their newly mined block.\n",
    "\n",
    "Let's begin with the transaction input datastructure:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "@dataclass\n",
    "class TxIn:\n",
    "    prev_tx: bytes # prev transaction ID: hash256 of prev tx contents\n",
    "    prev_index: int # UTXO output index in the transaction\n",
    "    script_sig: Script = None # unlocking script, Script class coming a bit later below\n",
    "    sequence: int = 0xffffffff # originally intended for \"high frequency trades\", with locktime\n",
    "\n",
    "tx_in = TxIn(\n",
    "    prev_tx = bytes.fromhex('46325085c89fb98a4b7ceee44eac9b955f09e1ddc86d8dad3dfdcba46b4d36b2'),\n",
    "    prev_index = 1,\n",
    "    script_sig = None, # this field will have the digital signature, to be inserted later\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The first two variables (`prev_tx, prev_index`) identify a specific Output that we are going to spend. Note again that nowhere are we specifying how much of the output we want to spend. We must spend the output (or a \"UTXO\" as it's often called, short for Unspent Transaction Output) in its entirety. Once we consume this UTXO in its entirety we are free to \"chunk up\" its value into however many outputs we like, and optionally send some of those chunks back to our own address. Anyway, in this case we are identifying the transaction that sent us the Bitcoins, and we're saying that the Output we intend to spend is at the 1th index of it. The 0th index went to some other unknown address controlled by the faucet, which we won't be able to spend because we don't control it (we don't have the private key and won't be able to create the digital signature).\n",
    "\n",
    "The `script_sig` field we are going to revisit later. This is where the digital signature will go, cryptographically signing the desired transaction with our private key and effectively saying \"I approve this transaction as the possessor of the private key whose public key hashes to 4b3518229b0d3554fe7cd3796ade632aff3069d8\".\n",
    "\n",
    "`sequence` was in the original Bitcoin implementation from Satoshi and was intended to provide a type of \"high frequency trade\" functionality, but has very limited uses today and we'll mostly ignore.\n",
    "\n",
    "**Calculating the fee.** Great, so the above data structure references the Inputs of our transaction (1 input here). Let's now create the data structures for the two outputs of our transaction. To get a sense of the going \"market rate\" of transaction fees there are a number of websites available, or we can just scroll through some transactions in a recent block to get a sense. A number of recent transactions (including the one above) were packaged into a block even at <1 satoshi/byte (satoshi is 1e-8 of a bitcoin). So let's try to go with a very generous fee of maybe 10 sat/B, or a total transaction fee of 0.0000001. In that case we are taking our input of 0.001 BTC = 100,000 sat, the fee will be 2,500 sat (because our transaction will be approx. 250 bytes), we are going to send 50,000 sat to our target wallet, and the rest (`100,000 - 2,500 - 50,000 = 47,500`) back to us.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "@dataclass\n",
    "class TxOut:\n",
    "    amount: int # in units of satoshi (1e-8 of a bitcoin)\n",
    "    script_pubkey: Script = None # locking script\n",
    "\n",
    "tx_out1 = TxOut(\n",
    "    amount = 50000 # we will send this 50,000 sat to our target wallet\n",
    ")\n",
    "tx_out2 = TxOut(\n",
    "    amount = 47500 # back to us\n",
    ")\n",
    "# the fee of 2500 does not need to be manually specified, the miner will claim it"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Populating the locking scripts**. We're now going to populate the `script_pubkey` \"locking script\" for both of these outputs. Essentially we want to specify the conditions under which each output can be spent by some future transaction. As mentioned, Bitcoin has a rich scripting language with almost 100 instructions that can be sequenced into various locking / unlocking scripts, but here we are going to use the super standard and ubiquitous script we already saw above, and which was also used by the faucet to pay us. To indicate the ownership of both of these outputs we basically want to specify the public key hash of whoever can spend the output. Except we have to dress that up with the \"rich scripting language\" padding. Ok here we go."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Recall that the locking script in the faucet transaction had this form when we looked at it in the Bitcoin block explorer. The public key hash of the owner of the Output is sandwiched between a few Bitcoin Scripting Language op codes, which we'll cover in a bit:\n",
    "\n",
    "```\n",
    "OP_DUP\n",
    "OP_HASH160\n",
    "4b3518229b0d3554fe7cd3796ade632aff3069d8\n",
    "OP_EQUALVERIFY\n",
    "OP_CHECKSIG\n",
    "```\n",
    "\n",
    "We need to create this same structure and encode it into bytes, but we want to swap out the public key hash with the new owner's hashes. The op codes (like OP_DUP etc.) all get encoded as integers via a fixed schema. Here it is:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1976a91475b0c9fc784ba2ea0839e3cdf2669495cac6707388ac\n",
      "1976a9144b3518229b0d3554fe7cd3796ade632aff3069d888ac\n"
     ]
    }
   ],
   "source": [
    "\n",
    "def encode_int(i, nbytes, encoding='little'):\n",
    "    \"\"\" encode integer i into nbytes bytes using a given byte ordering \"\"\"\n",
    "    return i.to_bytes(nbytes, encoding)\n",
    "\n",
    "def encode_varint(i):\n",
    "    \"\"\" encode a (possibly but rarely large) integer into bytes with a super simple compression scheme \"\"\"\n",
    "    if i < 0xfd:\n",
    "        return bytes([i])\n",
    "    elif i < 0x10000:\n",
    "        return b'\\xfd' + encode_int(i, 2)\n",
    "    elif i < 0x100000000:\n",
    "        return b'\\xfe' + encode_int(i, 4)\n",
    "    elif i < 0x10000000000000000:\n",
    "        return b'\\xff' + encode_int(i, 8)\n",
    "    else:\n",
    "        raise ValueError(\"integer too large: %d\" % (i, ))\n",
    "\n",
    "@dataclass\n",
    "class Script:\n",
    "    cmds: List[Union[int, bytes]]\n",
    "\n",
    "    def encode(self):\n",
    "        out = []\n",
    "        for cmd in self.cmds:\n",
    "            if isinstance(cmd, int):\n",
    "                # an int is just an opcode, encode as a single byte\n",
    "                out += [encode_int(cmd, 1)]\n",
    "            elif isinstance(cmd, bytes):\n",
    "                # bytes represent an element, encode its length and then content\n",
    "                length = len(cmd)\n",
    "                assert length < 75 # any longer than this requires a bit of tedious handling that we'll skip here\n",
    "                out += [encode_int(length, 1), cmd]\n",
    "\n",
    "        ret = b''.join(out)\n",
    "        return encode_varint(len(ret)) + ret\n",
    "\n",
    "    \n",
    "# the first output will go to our 2nd wallet\n",
    "out1_pkb_hash = PublicKey.from_point(public_key2).encode(compressed=True, hash160=True)\n",
    "out1_script = Script([118, 169, out1_pkb_hash, 136, 172]) # OP_DUP, OP_HASH160, <hash>, OP_EQUALVERIFY, OP_CHECKSIG\n",
    "print(out1_script.encode().hex())\n",
    "\n",
    "# the second output will go back to us\n",
    "out2_pkb_hash = PublicKey.from_point(public_key).encode(compressed=True, hash160=True)\n",
    "out2_script = Script([118, 169, out2_pkb_hash, 136, 172])\n",
    "print(out2_script.encode().hex())\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Ok we're now going to effectively declare the owners of both outputs of our transaction by specifying the public key hashes (padded by the Script op codes). We'll see exactly how these locking scripts work for the Ouputs in a bit when we create the unlocking script for the Input. For now it is important to understand that we are effectively declaring the owner of each output UTXO by identifying a specific public key hash. With the locking script specified as above, only the person who has the original public key (and its associated secret key) will be able to spend the UTXO."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "tx_out1.script_pubkey = out1_script\n",
    "tx_out2.script_pubkey = out2_script"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Digital Signature\n",
    "\n",
    "Now for the important part, we're looping around to specifying the `script_sig` of the transaction input `tx_in`, which we skipped over above. In particular we are going to craft a digital signature that effectively says \"I, the owner of the private key associated with the public key hash on the referenced transaction's output's locking script approve the spend of this UTXO as an input of this transaction\". Unfortunately this is again where Bitcoin gets pretty fancy because you can actually only sign parts of Transactions, and a number of signatures can be assembled from a number of parties and combined in various ways. As we did above, we will only cover the (by far) most common use case of signing the entire transaction and, and constructing the unlocking script specifically to only satisfy the locking script of the exact form above (OP_DUP, OP_HASH160, \\<hash\\>, OP_EQUALVERIFY, OP_CHECKSIG).\n",
    "\n",
    "First, we need to create a pure bytes \"message\" that we will be digitally signing. In this case, the message is the encoding of the entire transaction. So this is awkward - the entire transaction can't be encoded into bytes yet because we haven't finished it! It is still missing our signature, which we are still trying to construct.\n",
    "\n",
    "Instead, when we are serializing the transaction input that we wish to sign, the rule is to replace the encoding of the `script_sig` (which we don't have, because again we're just trying to produce it...) with the `script_pubkey` of the transaction output this input is pointing back to. All other transaction input's `script_sig` is also replaced with an empty script, because those inputs can belong to many other owners who can individually and independently contribute their own signatures. Ok I'm not sure if this is making sense any right now. So let's just see it in code.\n",
    "    \n",
    "We need the final datastructure, the actual Transaction, so we can serialize it into the bytes message. It is mostly a thin container for a list of `TxIn`s and list of `TxOut`s: the inputs and outputs. We then implement the serialization for the new `Tx` class, and also the serialization for `TxIn` and `TxOut` class, so we can serialize the entire transaction to bytes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "@dataclass\n",
    "class Tx:\n",
    "    version: int\n",
    "    tx_ins: List[TxIn]\n",
    "    tx_outs: List[TxOut]\n",
    "    locktime: int = 0\n",
    "\n",
    "    def encode(self, sig_index=-1) -> bytes:\n",
    "        \"\"\"\n",
    "        Encode this transaction as bytes.\n",
    "        If sig_index is given then return the modified transaction\n",
    "        encoding of this tx with respect to the single input index.\n",
    "        This result then constitutes the \"message\" that gets signed\n",
    "        by the aspiring transactor of this input.\n",
    "        \"\"\"\n",
    "        out = []\n",
    "        # encode metadata\n",
    "        out += [encode_int(self.version, 4)]\n",
    "        # encode inputs\n",
    "        out += [encode_varint(len(self.tx_ins))]\n",
    "        if sig_index == -1:\n",
    "            # we are just serializing a fully formed transaction\n",
    "            out += [tx_in.encode() for tx_in in self.tx_ins]\n",
    "        else:\n",
    "            # used when crafting digital signature for a specific input index\n",
    "            out += [tx_in.encode(script_override=(sig_index == i))\n",
    "                    for i, tx_in in enumerate(self.tx_ins)]\n",
    "        # encode outputs\n",
    "        out += [encode_varint(len(self.tx_outs))]\n",
    "        out += [tx_out.encode() for tx_out in self.tx_outs]\n",
    "        # encode... other metadata\n",
    "        out += [encode_int(self.locktime, 4)]\n",
    "        out += [encode_int(1, 4) if sig_index != -1 else b''] # 1 = SIGHASH_ALL\n",
    "        return b''.join(out)\n",
    "\n",
    "# we also need to know how to encode TxIn. This is just serialization protocol.\n",
    "def txin_encode(self, script_override=None):\n",
    "    out = []\n",
    "    out += [self.prev_tx[::-1]] # little endian vs big endian encodings... sigh\n",
    "    out += [encode_int(self.prev_index, 4)]\n",
    "\n",
    "    if script_override is None:\n",
    "        # None = just use the actual script\n",
    "        out += [self.script_sig.encode()]\n",
    "    elif script_override is True:\n",
    "        # True = override the script with the script_pubkey of the associated input\n",
    "        out += [self.prev_tx_script_pubkey.encode()]\n",
    "    elif script_override is False:\n",
    "        # False = override with an empty script\n",
    "        out += [Script([]).encode()]\n",
    "    else:\n",
    "        raise ValueError(\"script_override must be one of None|True|False\")\n",
    "\n",
    "    out += [encode_int(self.sequence, 4)]\n",
    "    return b''.join(out)\n",
    "\n",
    "TxIn.encode = txin_encode # monkey patch into the class\n",
    "\n",
    "# and TxOut as well\n",
    "def txout_encode(self):\n",
    "    out = []\n",
    "    out += [encode_int(self.amount, 8)]\n",
    "    out += [self.script_pubkey.encode()]\n",
    "    return b''.join(out)\n",
    "\n",
    "TxOut.encode = txout_encode # monkey patch into the class\n",
    "\n",
    "tx = Tx(\n",
    "    version = 1,\n",
    "    tx_ins = [tx_in], \n",
    "    tx_outs = [tx_out1, tx_out2],\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Before we can call `.encode` on our Transaction object and get its content as bytes so we can sign it, we need to satisfy the Bitcoin rule where we replace the encoding of the script_sig (which we don't have, because again we're just trying to produce it...) with the script_pubkey of the transaction output this input is pointing back to. [Here](https://www.blockchain.com/btc-testnet/tx/46325085c89fb98a4b7ceee44eac9b955f09e1ddc86d8dad3dfdcba46b4d36b2) is the link once again to the original transaction. We are trying to spend its Output at Index 1, and the script_pubkey is, again, \n",
    "\n",
    "```\n",
    "OP_DUP\n",
    "OP_HASH160\n",
    "4b3518229b0d3554fe7cd3796ade632aff3069d8\n",
    "OP_EQUALVERIFY\n",
    "OP_CHECKSIG\n",
    "```\n",
    "\n",
    "This particular Block Explorer website does not allow us to get this in the raw (bytes) form, so we will re-create the data structure as a Script:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "recall out2_pkb_hash is just raw bytes of the hash of public_key:  4b3518229b0d3554fe7cd3796ade632aff3069d8\n",
      "1976a9144b3518229b0d3554fe7cd3796ade632aff3069d888ac\n"
     ]
    }
   ],
   "source": [
    "source_script = Script([118, 169, out2_pkb_hash, 136, 172]) # OP_DUP, OP_HASH160, <hash>, OP_EQUALVERIFY, OP_CHECKSIG\n",
    "print(\"recall out2_pkb_hash is just raw bytes of the hash of public_key: \", out2_pkb_hash.hex())\n",
    "print(source_script.encode().hex()) # we can get the bytes of the script_pubkey now"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'0100000001b2364d6ba4cbfd3dad8d6dc8dde1095f959bac4ee4ee7c4b8ab99fc885503246010000001976a9144b3518229b0d3554fe7cd3796ade632aff3069d888acffffffff0250c30000000000001976a91475b0c9fc784ba2ea0839e3cdf2669495cac6707388ac8cb90000000000001976a9144b3518229b0d3554fe7cd3796ade632aff3069d888ac0000000001000000'"
      ]
     },
     "execution_count": 44,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# monkey patch this into the input of the transaction we are trying sign and construct\n",
    "tx_in.prev_tx_script_pubkey = source_script\n",
    "\n",
    "# get the \"message\" we need to digitally sign!!\n",
    "message = tx.encode(sig_index = 0)\n",
    "message.hex()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Okay let's pause for a moment. We have encoded the transaction into bytes to create a \"message\", in the digital signature lingo. Think about what the above bytes encode, and what it is that we are about to sign. We are identifying the exact inputs of this transaction by referencing the outputs of a specific previous transactions (here, just 1 input of course). We are also identifying the exact outputs of this transaction (newly about to be minted UTXOs, so to speak) along with their `script_pubkey` fields, which in the most common case declare an owner of each output via their public key hash wrapped up in a Script. In particular, we are of course not including the `script_sig` of any of the other inputs when we are signing a specific input (you can see that the `txin_encode` function will set them to be empty scripts). In fact, in the fully general (though rare) case we may not even have them. So what this message really encodes is just the inputs and the new outputs, their amounts, and their owners (via the locking scripts specifying the public key hash of each owner).\n",
    "\n",
    "We are now ready to digitally sign the message with our private key. The actual signature itself is a tuple of two integers `(r, s)`. As with Elliptic Curve Cryptography (ECC) above, I will not cover the full mathematical details of the Elliptic Curve Digital Signature Algorithm (ECDSA). Instead just providing the code, and showing that it's not very scary:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Signature(r=47256385045018612897921731322704225983926443696060225906633967860304940939048, s=24798952842859654103158450705258206127588200130910777589265114945580848358502)"
      ]
     },
     "execution_count": 45,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "@dataclass\n",
    "class Signature:\n",
    "    r: int\n",
    "    s: int\n",
    "\n",
    "\n",
    "def sign(secret_key: int, message: bytes) -> Signature:\n",
    "    \n",
    "    # the order of the elliptic curve used in bitcoin\n",
    "    n = bitcoin_gen.n\n",
    "\n",
    "    # double hash the message and convert to integer\n",
    "    z = int.from_bytes(sha256(sha256(message)), 'big')\n",
    "\n",
    "    # generate a new secret/public key pair at random\n",
    "    sk = random.randrange(1, n)\n",
    "    P = sk * bitcoin_gen.G\n",
    "    \n",
    "    # calculate the signature\n",
    "    r = P.x\n",
    "    s = inv(sk, n) * (z + secret_key * r) % n\n",
    "    if s > n / 2:\n",
    "        s = n - s\n",
    "\n",
    "    sig = Signature(r, s)\n",
    "    return sig\n",
    "\n",
    "def verify(public_key: Point, message: bytes, sig: Signature) -> bool:\n",
    "    # just a stub for reference on how a signature would be verified in terms of the API\n",
    "    # we don't need to verify any signatures to craft a transaction, but we would if we were mining\n",
    "    pass\n",
    "\n",
    "random.seed(int.from_bytes(sha256(message), 'big')) # see note below\n",
    "sig = sign(secret_key, message)\n",
    "sig"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In the above you will notice a very often commented on (and very rightly so) subtlety: In this naive form we are generating a random number inside the signing process when we generate `sk`. This means that our signature would change every time we sign, which is undesirable for a large number of reasons, including the reproducibility of this exercise. It gets much worse very fast btw: if you sign two different messages with the same `sk`, an attacker can recover the secret key, yikes. Just ask the [Playstation 3](https://fahrplan.events.ccc.de/congress/2010/Fahrplan/attachments/1780_27c3_console_hacking_2010.pdf) guys. There is a specific standard (called RFC 6979) that recommends a specific way to generate `sk` deterministically, but we skip it here for brevity. Instead I implement a poor man's version here where I seed rng with a hash of the message. Please don't use this anywhere close to anything that touches production.\n",
    "\n",
    "Let's now implement the `encode` function of a `Signature` so we can broadcast it over the Bitcoin protocol. To do so we are using the [DER Encoding](https://en.bitcoin.it/wiki/BIP_0062#DER_encoding):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'30440220687a2a84aeaf387d8c6e9752fb8448f369c0f5da9fe695ff2eceb7fd6db8b728022036d3b5bc2746c20b32634a1a2d8f3b03f9ead38440b3f41451010f61e89ba466'"
      ]
     },
     "execution_count": 46,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def signature_encode(self) -> bytes:\n",
    "    \"\"\" return the DER encoding of this signature \"\"\"\n",
    "\n",
    "    def dern(n):\n",
    "        nb = n.to_bytes(32, byteorder='big')\n",
    "        nb = nb.lstrip(b'\\x00') # strip leading zeros\n",
    "        nb = (b'\\x00' if nb[0] >= 0x80 else b'') + nb # preprend 0x00 if first byte >= 0x80\n",
    "        return nb\n",
    "\n",
    "    rb = dern(self.r)\n",
    "    sb = dern(self.s)\n",
    "    content = b''.join([bytes([0x02, len(rb)]), rb, bytes([0x02, len(sb)]), sb])\n",
    "    frame = b''.join([bytes([0x30, len(content)]), content])\n",
    "    return frame\n",
    "\n",
    "Signature.encode = signature_encode # monkey patch into the class\n",
    "sig_bytes = sig.encode()\n",
    "sig_bytes.hex()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We are finally ready to generate the `script_sig` for the single input of our transaction. For a reason that will become clear in a moment, it will contain exactly two elements: 1) the signature and 2) the public key, both encoded as bytes:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Append 1 (= SIGHASH_ALL), indicating this DER signature we created encoded \"ALL\" of the tx (by far most common)\n",
    "sig_bytes_and_type = sig_bytes + b'\\x01'\n",
    "\n",
    "# Encode the public key into bytes. Notice we use hash160=False so we are revealing the full public key to Blockchain\n",
    "pubkey_bytes = PublicKey.from_point(public_key).encode(compressed=True, hash160=False)\n",
    "\n",
    "# Create a lightweight Script that just encodes those two things!\n",
    "script_sig = Script([sig_bytes_and_type, pubkey_bytes])\n",
    "tx_in.script_sig = script_sig"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Okay so now that we created both locking scripts (`script_pubkey`) and the unlocking scripts (`script_sig`) we can reflect briefly on how these two scripts interact in the Bitcoin scripting environment. On a high level, in the transaction validating process during mining, for each transaction input the two scripts get concatenated into a single script, which then runs in the \"Bitcoin VM\" (?). We can see now that concatenating the two scripts will look like:\n",
    "\n",
    "```\n",
    "<sig_bytes_and_type>\n",
    "<pubkey_bytes>\n",
    "OP_DUP\n",
    "OP_HASH160\n",
    "<pubkey_hash_bytes>\n",
    "OP_EQUALVERIFY\n",
    "OP_CHECKSIG\n",
    "```\n",
    "\n",
    "This then gets executed top to bottom with a typical stack-based push/pop scheme, where any bytes get pushed into the stack, and any ops will consume some inputs and push some outputs. So here we push to the stack the signature and the pubkey, then the pubkey gets duplicated (OP_DUP), it gets hashed (OP_HASH160), the hash gets compared to the `pubkey_hash_bytes` (OP_EQUALVERIFY), and finally the digital signature integrity is verified as having been signed by the associated private key."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We have now completed all the necessary steps! Let's take a look at a repr of our fully constructed transaction again:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Tx(version=1, tx_ins=[TxIn(prev_tx=b'F2P\\x85\\xc8\\x9f\\xb9\\x8aK|\\xee\\xe4N\\xac\\x9b\\x95_\\t\\xe1\\xdd\\xc8m\\x8d\\xad=\\xfd\\xcb\\xa4kM6\\xb2', prev_index=1, script_sig=Script(cmds=[b\"0D\\x02 hz*\\x84\\xae\\xaf8}\\x8cn\\x97R\\xfb\\x84H\\xf3i\\xc0\\xf5\\xda\\x9f\\xe6\\x95\\xff.\\xce\\xb7\\xfdm\\xb8\\xb7(\\x02 6\\xd3\\xb5\\xbc'F\\xc2\\x0b2cJ\\x1a-\\x8f;\\x03\\xf9\\xea\\xd3\\x84@\\xb3\\xf4\\x14Q\\x01\\x0fa\\xe8\\x9b\\xa4f\\x01\", b'\\x03\\xb9\\xb5T\\xe2P\"\\xc2\\xaeT\\x9b\\x0c0\\xc1\\x8d\\xf0\\xa8\\xe0IR#\\xf6\\'\\xae8\\xdf\\t\\x92\\xef\\xb4w\\x94u']), sequence=4294967295)], tx_outs=[TxOut(amount=50000, script_pubkey=Script(cmds=[118, 169, b'u\\xb0\\xc9\\xfcxK\\xa2\\xea\\x089\\xe3\\xcd\\xf2f\\x94\\x95\\xca\\xc6ps', 136, 172])), TxOut(amount=47500, script_pubkey=Script(cmds=[118, 169, b'K5\\x18\"\\x9b\\r5T\\xfe|\\xd3yj\\xdec*\\xff0i\\xd8', 136, 172]))], locktime=0)"
      ]
     },
     "execution_count": 48,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tx"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Pretty lightweight, isn't it? There's not that much to a Bitcoin transaction. Let's encode it into bytes and show in hex:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'0100000001b2364d6ba4cbfd3dad8d6dc8dde1095f959bac4ee4ee7c4b8ab99fc885503246010000006a4730440220687a2a84aeaf387d8c6e9752fb8448f369c0f5da9fe695ff2eceb7fd6db8b728022036d3b5bc2746c20b32634a1a2d8f3b03f9ead38440b3f41451010f61e89ba466012103b9b554e25022c2ae549b0c30c18df0a8e0495223f627ae38df0992efb4779475ffffffff0250c30000000000001976a91475b0c9fc784ba2ea0839e3cdf2669495cac6707388ac8cb90000000000001976a9144b3518229b0d3554fe7cd3796ade632aff3069d888ac00000000'"
      ]
     },
     "execution_count": 54,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tx.encode().hex()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Transaction size in bytes:  225\n"
     ]
    }
   ],
   "source": [
    "print(\"Transaction size in bytes: \", len(tx.encode()))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally let's calculate the id of our finished transaction:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'245e2d1f87415836cbb7b0bc84e40f4ca1d2a812be0eda381f02fb2224b4ad69'"
      ]
     },
     "execution_count": 53,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def tx_id(self) -> str:\n",
    "    return sha256(sha256(self.encode()))[::-1].hex() # little/big endian conventions require byte order swap\n",
    "Tx.id = tx_id # monkey patch into the class\n",
    "\n",
    "tx.id() # once this transaction goes through, this will be its id"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We are now ready to broadcast the transaction to Bitcoin nodes around the world. We're literally blasting out the 225 bytes (embedded in a standard Bitcoin protocol network envelope) that define our transaction. The Bitcoin nodes will decode it, validate it, and include it into the next block they might mine any second now (if the fee is high enough). In English, those 225 bytes are saying \"Hello Bitcoin network, how are you? Great. I would like to create a new transaction that takes the output (UTXO) of the transaction 46325085c89fb98a4b7ceee44eac9b955f09e1ddc86d8dad3dfdcba46b4d36b2 at index 1, and I would like to chunk its amount into two outputs, one going to the address mrFF91kpuRbivucowsY512fDnYt6BWrvx9 for the amount 50,000 sat and the other going to the address mnNcaVkC35ezZSgvn8fhXEa9QTHSUtPfzQ for the amount 47,500 sat. (It is understood the rest of 2,500 sat will go to any miner who includes this transaction in their block). Here are the two pieces of documentation proving that I can spend this UTXO: my public key, and the digital signature generated by the associated private key, of the above letter of intent. Kkthx!\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We are going to broadcast this out to the network and see if it sticks! We could include a simple client here that speaks the Bitcoin protocol over `socket` to communicate to the nodes - we'd first do the handshake (sending versions back and forth) and then broadcast the transaction bytes above using the `tx` message. However, the code is somewhat long and not super exciting (it's a lot of serialization following the specific message formats described in the [Bitcoin protocol](https://en.bitcoin.it/wiki/Protocol_documentation)), so instead of further bloating this notebook I will use blockstream's helpful [tx/push](https://blockstream.info/testnet/tx/push) endpoint to broadcast the transaction. It's just a large textbox where we copy paste the raw transaction hex exactly as above, and hit \"Broadcast\". If you'd like to do this manually with raw Bitcoin protocol you'd want to look into my [SimpleNode](https://github.com/karpathy/cryptos/blob/main/cryptos/network.py) implementation and use that to communicate to a node over socket.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time; time.sleep(1.0) # now we wait :p, for the network to execute the transaction and include it in a block"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And here is the [transaction](https://www.blockchain.com/btc-testnet/tx/245e2d1f87415836cbb7b0bc84e40f4ca1d2a812be0eda381f02fb2224b4ad69)! We can see that our raw bytes were parsed out correctly and the transaction was judged to be valid, and was included in [Block 2005515](https://www.blockchain.com/btc-testnet/block/2005515). Our transaction was one of 31 transactions included in this block, and the miner claimed our fee as a thank you.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Putting it all together: One more consolidating transaction \n",
    "\n",
    "Let's put everything together now to create one last identity and consolidate all of our remaining funds in this one wallet."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Our third Bitcoin identity:\n",
      "1. secret key:  29595381593786747354608258168471648998894101022644411057647114205835530364276\n",
      "2. public key:  (10431688308521398859068831048649547920603040245302637088532768399600614938636, 74559974378244821290907538448690356815087741133062157870433812445804889333467)\n",
      "3. Bitcoin address:  mgh4VjZx5MpkHRis9mDsF2ZcKLdXoP3oQ4\n"
     ]
    }
   ],
   "source": [
    "secret_key3 = int.from_bytes(b\"Andrej's Super Secret 3rd Wallet\", 'big') # or just random.randrange(1, bitcoin_gen.n)\n",
    "assert 1 <= secret_key3 < bitcoin_gen.n # check it's valid\n",
    "public_key3 = secret_key3 * G\n",
    "address3 = PublicKey.from_point(public_key3).address(net='test', compressed=True)\n",
    "\n",
    "print(\"Our third Bitcoin identity:\")\n",
    "print(\"1. secret key: \", secret_key3)\n",
    "print(\"2. public key: \", (public_key3.x, public_key3.y))\n",
    "print(\"3. Bitcoin address: \", address3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And let's forge the transaction. We currently have 47,500 sat in our first wallet mnNcaVkC35ezZSgvn8fhXEa9QTHSUtPfzQ and 50,000 sat in our second wallet mrFF91kpuRbivucowsY512fDnYt6BWrvx9. We're going to create a transaction with these two as inputs, and a single output into the third wallet mgh4VjZx5MpkHRis9mDsF2ZcKLdXoP3oQ4. As before we'll pay 2500 sat as fee, so we're sending ourselves 50,000 + 47,500 - 2500 = 95,000 sat."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "361fbb9de4ef5bfa8c1cbd5eff818ed9273f6e1f74b41a7f9a9e8427c9008b93\n",
      "Tx(version=1, tx_ins=[TxIn(prev_tx=b'$^-\\x1f\\x87AX6\\xcb\\xb7\\xb0\\xbc\\x84\\xe4\\x0fL\\xa1\\xd2\\xa8\\x12\\xbe\\x0e\\xda8\\x1f\\x02\\xfb\"$\\xb4\\xadi', prev_index=0, script_sig=Script(cmds=[b'0D\\x02 \\x19\\x9aj\\xa5c\\x06\\xce\\xbc\\xda\\xcd\\x1e\\xba&\\xb5^\\xafo\\x92\\xebF\\xeb\\x90\\xd1\\xb7\\xe7rK\\xac\\xbe\\x1d\\x19\\x14\\x02 \\x10\\x1c\\rF\\xe036\\x1c`Ski\\x89\\xef\\xddo\\xa6\\x92&_\\xcd\\xa1dgn/I\\x88Xq\\x03\\x8a\\x01', b'\\x03\\x9a\\xc8\\xba\\xc8\\xf6\\xd9\\x16\\xb8\\xa8[E\\x8e\\x08~\\x0c\\xd0~jv\\xa6\\xbf\\xdd\\xe9\\xbbvk\\x17\\x08m\\x9a\\\\\\x8a']), sequence=4294967295), TxIn(prev_tx=b'$^-\\x1f\\x87AX6\\xcb\\xb7\\xb0\\xbc\\x84\\xe4\\x0fL\\xa1\\xd2\\xa8\\x12\\xbe\\x0e\\xda8\\x1f\\x02\\xfb\"$\\xb4\\xadi', prev_index=1, script_sig=Script(cmds=[b'0E\\x02!\\x00\\x84\\xecC#\\xed\\x07\\xdaJ\\xf6F \\x91\\xb4gbP\\xc3wRs0\\x19\\x1a?\\xf3\\xf5Y\\xa8\\x8b\\xea\\xe2\\xe2\\x02 w%\\x13\\x92\\xec/R2|\\xb7)k\\xe8\\x9c\\xc0\\x01Qn@9\\xba\\xdd*\\xd7\\xbb\\xc9P\\xc4\\xc1\\xb6\\xd7\\xcc\\x01', b'\\x03\\xb9\\xb5T\\xe2P\"\\xc2\\xaeT\\x9b\\x0c0\\xc1\\x8d\\xf0\\xa8\\xe0IR#\\xf6\\'\\xae8\\xdf\\t\\x92\\xef\\xb4w\\x94u']), sequence=4294967295)], tx_outs=[TxOut(amount=95000, script_pubkey=Script(cmds=[118, 169, b'\\x0c\\xe1vI\\xc10l)\\x1c\\xa9\\xe5\\x87\\xf8y;[\\x06V<\\xea', 136, 172]))], locktime=0)\n",
      "010000000269adb42422fb021f38da0ebe12a8d2a14c0fe484bcb0b7cb365841871f2d5e24000000006a4730440220199a6aa56306cebcdacd1eba26b55eaf6f92eb46eb90d1b7e7724bacbe1d19140220101c0d46e033361c60536b6989efdd6fa692265fcda164676e2f49885871038a0121039ac8bac8f6d916b8a85b458e087e0cd07e6a76a6bfdde9bb766b17086d9a5c8affffffff69adb42422fb021f38da0ebe12a8d2a14c0fe484bcb0b7cb365841871f2d5e24010000006b48304502210084ec4323ed07da4af6462091b4676250c377527330191a3ff3f559a88beae2e2022077251392ec2f52327cb7296be89cc001516e4039badd2ad7bbc950c4c1b6d7cc012103b9b554e25022c2ae549b0c30c18df0a8e0495223f627ae38df0992efb4779475ffffffff0118730100000000001976a9140ce17649c1306c291ca9e587f8793b5b06563cea88ac00000000\n"
     ]
    }
   ],
   "source": [
    "# ----------------------------\n",
    "# first input of the transaction\n",
    "tx_in1 = TxIn(\n",
    "    prev_tx = bytes.fromhex('245e2d1f87415836cbb7b0bc84e40f4ca1d2a812be0eda381f02fb2224b4ad69'),\n",
    "    prev_index = 0,\n",
    "    script_sig = None, # digital signature to be inserted later\n",
    ")\n",
    "# reconstruct the script_pubkey locking this UTXO (note: it's the first output index in the \n",
    "# referenced transaction, but the owner is the second identity/wallet!)\n",
    "# recall this information is \"swapped in\" when we digitally sign the spend of this UTXO a bit later\n",
    "pkb_hash = PublicKey.from_point(public_key2).encode(compressed=True, hash160=True)\n",
    "tx_in1.prev_tx_script_pubkey = Script([118, 169, pkb_hash, 136, 172]) # OP_DUP, OP_HASH160, <hash>, OP_EQUALVERIFY, OP_CHECKSIG\n",
    "\n",
    "# ----------------------------\n",
    "# second input of the transaction\n",
    "tx_in2 = TxIn(\n",
    "    prev_tx = bytes.fromhex('245e2d1f87415836cbb7b0bc84e40f4ca1d2a812be0eda381f02fb2224b4ad69'),\n",
    "    prev_index = 1,\n",
    "    script_sig = None, # digital signature to be inserted later\n",
    ")\n",
    "pkb_hash = PublicKey.from_point(public_key).encode(compressed=True, hash160=True)\n",
    "tx_in2.prev_tx_script_pubkey = Script([118, 169, pkb_hash, 136, 172]) # OP_DUP, OP_HASH160, <hash>, OP_EQUALVERIFY, OP_CHECKSIG\n",
    "# ----------------------------\n",
    "# define the (single) output\n",
    "tx_out = TxOut(\n",
    "    amount = 95000,\n",
    "    script_pubkey = None, # locking script, inserted separately right below\n",
    ")\n",
    "# declare the owner as identity 3 above, by inserting the public key hash into the Script \"padding\"\n",
    "out_pkb_hash = PublicKey.from_point(public_key3).encode(compressed=True, hash160=True)\n",
    "out_script = Script([118, 169, out_pkb_hash, 136, 172]) # OP_DUP, OP_HASH160, <hash>, OP_EQUALVERIFY, OP_CHECKSIG\n",
    "tx_out.script_pubkey = out_script\n",
    "# ----------------------------\n",
    "\n",
    "# create the aspiring transaction object\n",
    "tx = Tx(\n",
    "    version = 1,\n",
    "    tx_ins = [tx_in1, tx_in2], # 2 inputs this time!\n",
    "    tx_outs = [tx_out], # ...and a single output\n",
    ")\n",
    "\n",
    "# ----------------------------\n",
    "# digitally sign the spend of the first input of this transaction\n",
    "# note that index 0 of the input transaction is our second identity! so it must sign here\n",
    "message1 = tx.encode(sig_index = 0)\n",
    "random.seed(int.from_bytes(sha256(message1), 'big'))\n",
    "sig1 = sign(secret_key2, message1) # identity 2 signs\n",
    "sig_bytes_and_type1 = sig1.encode() + b'\\x01' # DER signature + SIGHASH_ALL\n",
    "pubkey_bytes = PublicKey.from_point(public_key2).encode(compressed=True, hash160=False)\n",
    "script_sig1 = Script([sig_bytes_and_type1, pubkey_bytes])\n",
    "tx_in1.script_sig = script_sig1\n",
    "\n",
    "# ----------------------------\n",
    "# digitally sign the spend of the second input of this transaction\n",
    "# note that index 1 of the input transaction is our first identity, so it signs here\n",
    "message2 = tx.encode(sig_index = 1)\n",
    "random.seed(int.from_bytes(sha256(message2), 'big'))\n",
    "sig2 = sign(secret_key, message2) # identity 1 signs\n",
    "sig_bytes_and_type2 = sig2.encode() + b'\\x01' # DER signature + SIGHASH_ALL\n",
    "pubkey_bytes = PublicKey.from_point(public_key).encode(compressed=True, hash160=False)\n",
    "script_sig2 = Script([sig_bytes_and_type2, pubkey_bytes])\n",
    "tx_in2.script_sig = script_sig2\n",
    "\n",
    "# and that should be it!\n",
    "print(tx.id())\n",
    "print(tx)\n",
    "print(tx.encode().hex())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Again we head over to Blockstream [tx/push](https://blockstream.info/testnet/tx/push) endpoint and copy paste the transaction hex above and wait :)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time; time.sleep(1.0)\n",
    "# in Bitcoin main net a block will take about 10 minutes to mine\n",
    "# (Proof of Work difficulty is dynamically adjusted to make it so)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And [here](https://www.blockchain.com/btc-testnet/tx/361fbb9de4ef5bfa8c1cbd5eff818ed9273f6e1f74b41a7f9a9e8427c9008b93) is the transaction, as it eventually showed up, part of [Block 2005671](https://www.blockchain.com/btc-testnet/block/2005671), along with 25 other transacation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Exercise to the reader**: steal my bitcoins from my 3rd identity wallet (mgh4VjZx5MpkHRis9mDsF2ZcKLdXoP3oQ4) to your own wallet ;) If done successfully, [the 3rd wallet](https://www.blockchain.com/btc-testnet/address/mgh4VjZx5MpkHRis9mDsF2ZcKLdXoP3oQ4) will show \"Final Balance\" of 0. At the time of writing this is \n",
    "0.00095000 BTC, as we intended and expected."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And that's where we're going to wrap up! This is of course only very bare bones demonstration of Bitcoin that uses a now somewhat legacy-format P2PKH transaction style (not the more recent innovations including P2SH, Segwit, bech32, etc etc.), and of course we did not cover any of the transaction/block validation, mining, and so on. However, I hope this acts as a good intro to the core concepts of how value is represented in Bitcoin, and how cryptography is used to secure the transactions.\n",
    "\n",
    "In essence, we have a DAG of UTXOs that each have a certain `amount` and a locking `Script`, transactions fully consume and create UTXOs, and they are packaged into blocks by miners every 10 minutes. Economics is then used to achieve decentralization via proof of work: the probability that any entity gets to add a new block to the chain is proportional to their fraction of the network's total SHA256 hashing power.\n",
    "\n",
    "As I was writing my [karpathy/cryptos](https://github.com/karpathy/cryptos) library it was fun to reflect on where all of the code was going. The majority of the cryptographic complexity comes from ECC, ECDSA, and SHA256, which are relatively standard in the industry and you'd never want to actually implement yourself (\"don't roll your own crypto\"). On top of this, the core data structures of transactions, blocks, etc. are fairly straight forward, but there are a lot of non-glamorous details around the Bitcoin protocol, and the serialization / deserialization of all the data structures to and from bytes. On top of this, Bitcoin is a living, breathing, developing code base that is moving forward with new features to continue to scale, to further fortify its security, all while maintaining full backwards compatibility to avoid hard forks. Sometimes, respecting these constraints leads to some fairly gnarly constructs, e.g. I found Segwit in particular to not be very aesthetically pleasing to say the least. Other times, there is a large amount of complexity (e.g. with the scripting language and all of its op codes) that is rarely used in the majority of the basic point to point transactions. \n",
    "\n",
    "Lastly, I really enjoyed various historical aspects of Bitcoin. For example I found it highly amusing that some of the original satoshi bugs are still around, e.g. in how the mining difficulty is adjusted (there is an off by one error where the calculation is based on 2015 blocks instead of 2016), or how some of the op codes are buggy (e.g. original multisig). Or how some of the primordial satoshi ideas around high frequency trades (locktime / sequence) are still around, but find only limited use in a likely not-exactly-intended ways. Bitcoin is a code base with all the struggles of any other software project, but without the ability to break legacy functionality (this would require a hard fork).\n",
    "\n",
    "If you'd like to dig deeper I found [Mastering Bitcoin](https://www.amazon.com/Mastering-Bitcoin-Programming-Open-Blockchain/dp/1491954388) and [Programming Bitcoin](https://www.amazon.com/Programming-Bitcoin-Learn-Program-Scratch/dp/1492031496) to be very helpful references. I also implemented a much cleaner, separated, tested and more extensive version of everything above in my repo [karpathy/cryptos](https://github.com/karpathy/cryptos) if you'd like to use that as a reference instead in your own blockchain journey. I'll make sure to upload this notebook there as well. Oh and find me on [Twitter](https://twitter.com/karpathy).\n",
    "\n",
    "Hope you learned something and that this was fun!\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}

```


## Content of test_ecdsa.py

```python
"""
Test our ability to sign and verify digital signatures
"""

import os
from io import BytesIO

from cryptos.bitcoin import BITCOIN
from cryptos.keys import gen_key_pair
from cryptos.ecdsa import Signature, sign, verify
from cryptos.transaction import Tx

def test_ecdsa():

    # let's create two identities
    sk1, pk1 = gen_key_pair()
    sk2, pk2 = gen_key_pair() # pylint: disable=unused-variable

    message = ('user pk1 would like to pay user pk2 1 BTC kkthx').encode('ascii')

    # an evil user2 attempts to submit the transaction to the network with some totally random signature
    sig = Signature(int.from_bytes(os.urandom(32), 'big'), int.from_bytes(os.urandom(32), 'big'))
    # a few seconds later a hero miner inspects the candidate transaction
    is_legit = verify(pk1, message, sig)
    assert not is_legit
    # unlike user2, hero miner is honest and discards the transaction, all is well

    # evil user2 does not give up and tries to sign with his key pair
    sig = sign(sk2, message)
    is_legit = verify(pk1, message, sig)
    assert not is_legit
    # denied, again!

    # lucky for user2, user1 feels sorry for them and the hardships they have been through recently
    sig = sign(sk1, message)
    is_legit = verify(pk1, message, sig)
    assert is_legit
    # hero miner validates the transaction and adds it to their block
    # user2 happy, buys a Tesla, and promises to turn things around

    # the end.

def test_sig_der():

    # a transaction used as an example in programming bitcoin
    raw = bytes.fromhex('0100000001813f79011acb80925dfe69b3def355fe914bd1d96a3f5f71bf8303c6a989c7d1000000006b483045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031ccfcf21320b0277457c98f02207a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9c8e10615bed01210349fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e213bf016b278afeffffff02a135ef01000000001976a914bc3b654dca7e56b04dca18f2566cdaf02e8d9ada88ac99c39800000000001976a9141c4bc762dd5423e332166702cb75f40df79fea1288ac19430600')
    tx = Tx.decode(BytesIO(raw))
    der = tx.tx_ins[0].script_sig.cmds[0][:-1] # this is the DER signature of the first input on this tx. :-1 crops out the sighash-type byte
    sig = Signature.decode(der) # making sure no asserts get tripped up inside this call

    # from programming bitcoin chapter 4
    der = bytes.fromhex('3045022037206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c60221008ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec')
    sig = Signature.decode(der)
    assert sig.r == 0x37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6
    assert sig.s == 0x8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec

    # test that we can also recover back the same der encoding
    der2 = sig.encode()
    assert der == der2

```


## Content of test_block.py

```python
"""
Test Block
"""

from io import BytesIO

from cryptos.block import Block, calculate_new_bits, bits_to_target, target_to_bits
from cryptos.block import GENESIS_BLOCK

def test_block():

    raw = bytes.fromhex('020000208ec39428b17323fa0ddec8e887b4a7c53b8c0a0a220cfd0000000000000000005b0750fce0a889502d40508d39576821155e9c9e3f5c3157f961db38fd8b25be1e77a759e93c0118a4ffd71d')

    block = Block.decode(BytesIO(raw))
    assert block.version == 0x20000002
    assert block.prev_block == bytes.fromhex('000000000000000000fd0c220a0a8c3bc5a7b487e8c8de0dfa2373b12894c38e')
    assert block.merkle_root == bytes.fromhex('be258bfd38db61f957315c3f9e9c5e15216857398d50402d5089a8e0fc50075b')
    assert block.timestamp == 0x59a7771e
    assert block.bits == bytes.fromhex('e93c0118')
    assert block.nonce == bytes.fromhex('a4ffd71d')

    raw2 = block.encode()
    assert raw == raw2

    assert block.id() == '0000000000000000007e9e4c586439b0cdbe13b1370bdd9435d76a644d047523'
    assert block.target() == 0x0000000000000000013ce9000000000000000000000000000000000000000000
    assert int(block.difficulty()) == 888171856257 # difficulty of genesis block was 1 :|

def test_validate():

    raw = bytes.fromhex('04000000fbedbbf0cfdaf278c094f187f2eb987c86a199da22bbb20400000000000000007b7697b29129648fa08b4bcd13c9d5e60abb973a1efac9c8d573c71c807c56c3d6213557faa80518c3737ec1')
    block = Block.decode(BytesIO(raw))
    assert block.validate()

    raw = bytes.fromhex('04000000fbedbbf0cfdaf278c094f187f2eb987c86a199da22bbb20400000000000000007b7697b29129648fa08b4bcd13c9d5e60abb973a1efac9c8d573c71c807c56c3d6213557faa80518c3737ec0')
    block = Block.decode(BytesIO(raw))
    assert not block.validate()

def test_calculate_bits():

    dt = 302400
    prev_bits = bytes.fromhex('54d80118')
    next_bits = calculate_new_bits(prev_bits, dt)
    assert next_bits == bytes.fromhex('00157617')

    # make sure encoding/decidng of bits <-> target works
    for bits in [prev_bits, next_bits]:
        target = bits_to_target(bits)
        bits2 = target_to_bits(target)
        assert bits == bits2

def test_genesis_block():
    """
    Validate the Bitcoin mainnet genesis block header
    Reference: https://en.bitcoin.it/wiki/Genesis_block
    Original code: https://sourceforge.net/p/bitcoin/code/133/tree/trunk/main.cpp#l1613
    """
    block_bytes = GENESIS_BLOCK['main']
    assert len(block_bytes) == 80
    block = Block.decode(BytesIO(block_bytes))

    assert block.version == 1
    assert block.prev_block == b'\x00'*32 # ;)
    assert block.merkle_root.hex() == '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b'
    assert block.timestamp == 1231006505
    assert block.bits[::-1].hex() == '1d00ffff'
    assert int.from_bytes(block.nonce, 'little') == 2083236893

    # validate proof of work. by two extra zeros, too!
    assert block.id()                     == '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'
    assert format(block.target(), '064x') == '00000000ffff0000000000000000000000000000000000000000000000000000'
    assert block.validate()

```


## Content of test_keys.py

```python
"""
Test the generation of secret/public keypairs and bitcoin addreses
"""

from cryptos.keys import PublicKey, address_to_pkb_hash
from cryptos.bitcoin import BITCOIN

def test_public_key_gen():

    # Example taken from Chapter 4 of Mastering Bitcoin
    # https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc
    public_key = PublicKey.from_sk('1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD')
    assert format(public_key.x, '064x').upper() == 'F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A'
    assert format(public_key.y, '064x').upper() == '07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB'


def test_btc_addresses():

    # tuples of (net, compressed, secret key in hex, expected compressed bitcoin address string in b58check)
    tests = [
        # Mastering Bitcoin Chapter 4 example
        # https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc
        ('main', True, '3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6', '14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3'),
        # Bitcoin wiki page reference
        # https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses#How_to_create_Bitcoin_Address
        ('main', True, '18e14a7b6a307f426a94f8114701e7c8e774e7f9a47e2c2035db29a206321725', '1PMycacnJaSqwwJqjawXBErnLsZ7RkXUAs'),
        # Programming Bitcoin Chapter 4 Exercise 5
        ('main', True, 0x12345deadbeef, '1F1Pn2y6pDb68E5nYJJeba4TLg2U7B6KF1'),
        ('test', True, 2020**5, 'mopVkxp8UhXqRYbCYJsbeE1h1fiF64jcoH'),
        ('test', False, 5002, 'mmTPbXQFxboEtNRkwfh6K51jvdtHLxGeMA'),
    ]

    # test address encoding into b58check
    for net, compressed, secret_key, expected_address in tests:
        pk = PublicKey.from_sk(secret_key)
        addr = pk.address(net, compressed)
        assert addr == expected_address

    # test public key hash decoding from b58check
    for net, compressed, secret_key, address in tests:
        pk = PublicKey.from_sk(secret_key)
        # get the hash160 by stripping version byte and checksum
        pkb_hash = pk.encode(compressed, hash160=True)
        # now extract from the address, address_to_pkb_hash
        pkb_hash2 = address_to_pkb_hash(address)
        assert pkb_hash == pkb_hash2


def test_pk_sec():

    G = BITCOIN.gen.G

    # these examples are taken from Programming Bitcoin Chapter 4 exercises
    tests = [
        (5000 * G, False, '04ffe558e388852f0120e46af2d1b370f85854a8eb0841811ece0e3e03d282d57c315dc72890a4f10a1481c031b03b351b0dc79901ca18a00cf009dbdb157a1d10'),
        ((2018**5) * G, False, '04027f3da1918455e03c46f659266a1bb5204e959db7364d2f473bdf8f0a13cc9dff87647fd023c13b4a4994f17691895806e1b40b57f4fd22581a4f46851f3b06'),
        (0xdeadbeef12345 * G, False, '04d90cd625ee87dd38656dd95cf79f65f60f7273b67d3096e68bd81e4f5342691f842efa762fd59961d0e99803c61edba8b3e3f7dc3a341836f97733aebf987121'),
        (5001 * G, True, '0357a4f368868a8a6d572991e484e664810ff14c05c0fa023275251151fe0e53d1'),
        ((2019**5) * G, True, '02933ec2d2b111b92737ec12f1c5d20f3233a0ad21cd8b36d0bca7a0cfa5cb8701'),
        (0xdeadbeef54321 * G, True, '0296be5b1292f6c856b3c5654e886fc13511462059089cdf9c479623bfcbe77690'),
    ]

    for P, compressed, sec_gt in tests:
        # encode
        sec = PublicKey.from_point(P).encode(compressed=compressed).hex()
        assert sec == sec_gt
        # decode
        P2 = PublicKey.decode(bytes.fromhex(sec))
        assert P.x == P2.x and P.y == P2.y

```


## Content of __init__.py

```python

```


## Content of test_network.py

```python
"""
Test node network protocol comms handling classes / utils
"""

from io import BytesIO
from cryptos.network import NetworkEnvelope
from cryptos.network import (
    VersionMessage,
    GetHeadersMessage,
    HeadersMessage,
)
from cryptos.network import SimpleNode
from cryptos.block import Block

def test_encode_decode_network_envelope():

    msg = bytes.fromhex('f9beb4d976657261636b000000000000000000005df6e0e2')
    stream = BytesIO(msg)
    envelope = NetworkEnvelope.decode(stream, 'main')
    assert envelope.command == b'verack'
    assert envelope.payload == b''
    assert envelope.encode() == msg

    msg = bytes.fromhex('f9beb4d976657273696f6e0000000000650000005f1a69d2721101000100000000000000bc8f5e5400000000010000000000000000000000000000000000ffffc61b6409208d010000000000000000000000000000000000ffffcb0071c0208d128035cbc97953f80f2f5361746f7368693a302e392e332fcf05050001')
    stream = BytesIO(msg)
    envelope = NetworkEnvelope.decode(stream, 'main')
    assert envelope.command == b'version'
    assert envelope.payload == msg[24:]
    assert envelope.encode() == msg

def test_encode_version_payload():

    m = VersionMessage(
        timestamp=0,
        nonce=b'\x00'*8,
        user_agent=b'/programmingbitcoin:0.1/',
    )

    assert m.encode().hex() == '7f11010000000000000000000000000000000000000000000000000000000000000000000000ffff00000000208d000000000000000000000000000000000000ffff00000000208d0000000000000000182f70726f6772616d6d696e67626974636f696e3a302e312f0000000000'

def test_encode_getheaders_payload():
    block_hex = '0000000000000000001237f46acddf58578a37e213d2a6edc4884a2fcad05ba3'
    m = GetHeadersMessage(
        start_block=bytes.fromhex(block_hex),
    )
    assert m.encode().hex() == '7f11010001a35bd0ca2f4a88c4eda6d213e2378a5758dfcd6af437120000000000000000000000000000000000000000000000000000000000000000000000000000000000'

def test_decode_headers_payload():
    hex_msg = '0200000020df3b053dc46f162a9b00c7f0d5124e2676d47bbe7c5d0793a500000000000000ef445fef2ed495c275892206ca533e7411907971013ab83e3b47bd0d692d14d4dc7c835b67d8001ac157e670000000002030eb2540c41025690160a1014c577061596e32e426b712c7ca00000000000000768b89f07044e6130ead292a3f51951adbd2202df447d98789339937fd006bd44880835b67d8001ade09204600'
    s = BytesIO(bytes.fromhex(hex_msg))
    headers = HeadersMessage.decode(s)
    assert len(headers.blocks) == 2
    for b in headers.blocks:
        assert isinstance(b, Block)

def test_handshake():

    node = SimpleNode(
        host='testnet.programmingbitcoin.com',
        net='test',
    )
    node.handshake()
    node.close()

```


## Content of test_hash.py

```python
import hashlib
from cryptos.sha256 import sha256
from cryptos.ripemd160 import ripemd160

def test_sha256():

    test_bytes = [
        b'',
        b'abc', # as seen in NIST docs
        b'hello',
        b'a longer message to make sure that a larger number of blocks works okay too'*15
    ]

    for b in test_bytes:
        gt = hashlib.sha256(b).hexdigest()
        yolo = sha256(b).hex()
        assert gt == yolo

def test_ripemd160():

    # taken from the ripemd160 docs
    # https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
    test_pairs = [
        ('', '9c1185a5c5e9fc54612808977ee8f548b2258d31'),
        ('a', '0bdc9d2d256b3ee9daae347be6f4dc835a467ffe'),
        ('abc', '8eb208f7e05d987a9b044a8e98c6b087f15a0bfc'),
        ('message digest', '5d0689ef49d2fae572b881b123a85ffa21595f36'),
        ('1234567890'*8, '9b752e45573d4b39f4dbd3323cab82bf63326bfb'),
        # ('a'*1000000, '52783243c1697bdbe16d37f97f68f08325dc1528'), # can take a while to compute
        ('a'*1000, 'aa69deee9a8922e92f8105e007f76110f381e9cf'), # I made this shorter one up instead
    ]

    for b, gt in test_pairs:
        yolo = ripemd160(b.encode('ascii')).hex()
        assert gt == yolo

```


## Content of test_tx.py

```python
"""
Test Transaction
"""

from io import BytesIO

from cryptos.transaction import Tx, TxIn, TxOut, Script
from cryptos.keys import PublicKey, address_to_pkb_hash
from cryptos.ecdsa import sign

def test_legacy_decode():

    # Example taken from Programming Bitcoin, Chapter 5
    raw = bytes.fromhex('0100000001813f79011acb80925dfe69b3def355fe914bd1d96a3f5f71bf8303c6a989c7d1000000006b483045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031ccfcf21320b0277457c98f02207a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9c8e10615bed01210349fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e213bf016b278afeffffff02a135ef01000000001976a914bc3b654dca7e56b04dca18f2566cdaf02e8d9ada88ac99c39800000000001976a9141c4bc762dd5423e332166702cb75f40df79fea1288ac19430600')
    tx = Tx.decode(BytesIO(raw))

    # metadata parsing
    assert tx.version == 1
    assert tx.segwit is False
    # input parsing
    assert len(tx.tx_ins) == 1
    assert tx.tx_ins[0].prev_tx == bytes.fromhex('d1c789a9c60383bf715f3f6ad9d14b91fe55f3deb369fe5d9280cb1a01793f81')
    assert tx.tx_ins[0].prev_index == 0
    assert tx.tx_ins[0].sequence == 0xfffffffe
    assert tx.tx_ins[0].witness is None
    # output parsing
    assert len(tx.tx_outs) == 2
    assert tx.tx_outs[0].amount == 32454049
    assert tx.tx_outs[1].amount == 10011545
    # locktime parsing
    assert tx.locktime == 410393
    # id calculation
    assert tx.id() == '452c629d67e41baec3ac6f04fe744b4b9617f8f859c63b3002f8684e7a4fee03'
    # fee calculation
    assert tx.fee() == 40000

    # check correct decoding/encoding
    raw2 = tx.encode()
    assert raw == raw2

    # validate the transaction as Bitcoin law-abiding and cryptographically authentic
    assert tx.validate()

    # fudge the r in the (r,s) digital signature tuple, this should break validation because CHECKSIG will fail
    sigb = tx.tx_ins[0].script_sig.cmds[0]
    sigb2 = sigb[:6] + bytes([(sigb[6] + 1) % 255]) + sigb[7:]
    tx.tx_ins[0].script_sig.cmds[0] = sigb2
    assert not tx.validate()
    tx.tx_ins[0].script_sig.cmds[0] = sigb # revert to original
    assert tx.validate()

    # fudge the public key, should again break validation because pk hash won't match
    pkb = tx.tx_ins[0].script_sig.cmds[1]
    pkb2 = pkb[:6] + bytes([(pkb[6] + 1) % 255]) + pkb[7:]
    tx.tx_ins[0].script_sig.cmds[1] = pkb2
    assert not tx.validate()
    tx.tx_ins[0].script_sig.cmds[1] = pkb # revert to original
    assert tx.validate()

def test_segwit_decode():

    # I snatched this transaction at random from the stream of transactions
    raw = bytes.fromhex('010000000001026c4224e4d6bab0cfdfd67870e084cda34e42d3544b3c77d310df40831fa4f5061700000023220020fb24ee0fec024ff3ff03c44d16ca523b78fd33ebaab99176e98b3f5e0e78da9dffffffffe8faf73aee5a09b1b678277fc63150dff639c97521e9088d6721a2b995f33664010000002322002083e1adc1eb82945fa99500bcd9df963b0e731524fd8eb25ef205e88d3bd7ab77ffffffff03a0370a00000000001976a914b00ff32bbc990acde3e5ac022e6d4120fb168f1e88ac7f791300000000001976a914128afed7e8d4e6f3a9d2d38ad560c307ebf392ba88ac54115c00000000001976a914c65d16caa1d8c1c46cc1bfac92eff06b02d8afcc88ac04004830450221009d93dc766b4a3417d7daccffe39719cd0344779c19d589d3a078625139a7dcd50220267c1b9b365d0eaa3b036771cbfc994c2b1c5b29e5107f023f036360cb60c8b50147304402206346b5c2bfa243c9cd0c5056abedfadc79e4a2b67b918315fc3faf79dfd12d7602203f729a665afd02ceb4b07898c06c81f0dfc378f66409ed828a4b5fe84f9287550169522102b951c91d97118489d1980ec472d89b5bc98fb98d0bafa17aca238d18a758b8642103d45b78e2a683330c62878e44610a5d1c8d40bd1f261b1110940b1b8a5aecd3e82103796ecd1667be6e20af571c46517e4ecf5e83052df864266658dd7f88e63efa6153ae0400483045022100e396deff2fe6dd6081e35f9dced6e09ea1b8b4830ae322b5d58986596996893d0220485420653c118c1a13b48941166b242077530d2b3cab908abe67af6b96ef2850014730440220171e11f4d6a106464a94e29f46750803a7deb214e6fbe2140ec5d80577dded0e02203483ab0c685f66e17b4afa86ba053732b43ff1ca7654796e72b69bd224bf26c4016952210375e42f77749f92a6b54c8e85fab2209e6807e15a3768c024a5cab01dc301c0282103fd4969521bd2d0f8e147c16655ae9c29dc48cb4f124b7a6398db78b1cbc878a221036bc18f387d1e4ba80492854cee639bd4ab6e3a310d9faa6f17350bbdc4c029d053ae25680a00')
    tx = Tx.decode(BytesIO(raw))

    # metadata parsing
    assert tx.version == 1
    assert tx.segwit is True
    # input parsing
    assert len(tx.tx_ins) == 2
    assert tx.tx_ins[0].witness is not None
    assert tx.tx_ins[1].witness is not None
    # output parsing
    assert len(tx.tx_outs) == 3
    assert tx.tx_outs[0].amount == 669600
    assert tx.tx_outs[1].amount == 1276287
    assert tx.tx_outs[2].amount == 6033748
    # id calculation
    assert tx.id() == '3ecf9b3d965cfaa2c472f09b5f487fbd838e4e1f861e3542c541d39c5cb7bc25'
    assert tx.fee() == 31922

    # check correct decoding/encoding
    raw2 = tx.encode()
    assert raw == raw2

def test_create_tx():
    # this example follows Programming Bitcoin Chapter 7

    # define the inputs of our aspiring transaction
    prev_tx = bytes.fromhex('0d6fe5213c0b3291f208cba8bfb59b7476dffacc4e5cb66f6eb20a080843a299')
    prev_index = 13
    tx_in = TxIn(prev_tx, prev_index, net='test')

    # change output that goes back to us
    amount = int(0.33 * 1e8) # 0.33 tBTC in units of satoshi
    pkb_hash = address_to_pkb_hash('mzx5YhAH9kNHtcN481u6WkjeHjYtVeKVh2')
    script = Script([118, 169, pkb_hash, 136, 172]) # OP_DUP, OP_HASH160, <hash>, OP_EQUALVERIFY, OP_CHECKSIG
    tx_out_change = TxOut(amount=amount, script_pubkey=script)

    # target output that goes to a lucky recepient
    amount = int(0.1 * 1e8) # 0.1 tBTC in units of satoshi
    pkb_hash = address_to_pkb_hash('mnrVtF8DWjMu839VW3rBfgYaAfKk8983Xf')
    script = Script([118, 169, pkb_hash, 136, 172]) # OP_DUP, OP_HASH160, <hash>, OP_EQUALVERIFY, OP_CHECKSIG
    tx_out_target = TxOut(amount=amount, script_pubkey=script)

    # create the desired transaction object
    tx = Tx(1, [tx_in], [tx_out_change, tx_out_target])

    # validate the intended fee of 0.01 tBTC
    assert tx.fee() == int(0.01 * 1e8)

    # produce the unlocking script for this p2pkh tx: [<signature>, <pubkey>]

    # first produce the <pubkey> that will satisfy OP_EQUALVERIFY on the locking script
    sk = 8675309 # the secret key that produced the public key that produced the hash that is on that input tx's locking script
    pk = PublicKey.from_sk(sk)
    sec = pk.encode(compressed=True) # sec encoded public key as bytes
    # okay but anyone with the knowledge of the public key could have done this part if this public
    # key was previously used (and hence revealed) somewhere on the blockchain

    # now produce the digital signature that will satisfy the OP_CHECKSIG on the locking script
    enc = tx.encode(sig_index=0)
    sig = sign(sk, enc) # only and uniquely the person with the secret key can do this
    der = sig.encode()
    der_and_type = der + b'\x01' # 1 = SIGHASH_ALL, indicating this der signature encoded "ALL" of the tx

    # set the unlocking script into the transaction
    tx_in.script_sig = Script([der_and_type, sec])

    # final check: ensure that our manually constructed transaction is all valid and ready to send out to the wild
    assert tx.validate()

    # peace of mind: fudge the signature and try again
    der = der[:6] + bytes([(der[6] + 1) % 255]) + der[7:]
    der_and_type = der + b'\x01'
    tx_in.script_sig = Script([der_and_type, sec])
    assert not tx.validate()

def test_is_coinbase():

    # not coinbase
    raw = bytes.fromhex('0100000001813f79011acb80925dfe69b3def355fe914bd1d96a3f5f71bf8303c6a989c7d1000000006b483045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031ccfcf21320b0277457c98f02207a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9c8e10615bed01210349fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e213bf016b278afeffffff02a135ef01000000001976a914bc3b654dca7e56b04dca18f2566cdaf02e8d9ada88ac99c39800000000001976a9141c4bc762dd5423e332166702cb75f40df79fea1288ac19430600')
    tx = Tx.decode(BytesIO(raw))
    assert not tx.is_coinbase()

    # is coinbase
    raw = bytes.fromhex('01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff5e03d71b07254d696e656420627920416e74506f6f6c20626a31312f4542312f4144362f43205914293101fabe6d6d678e2c8c34afc36896e7d9402824ed38e856676ee94bfdb0c6c4bcd8b2e5666a0400000000000000c7270000a5e00e00ffffffff01faf20b58000000001976a914338c84849423992471bffb1a54a8d9b1d69dc28a88ac00000000')
    tx = Tx.decode(BytesIO(raw))
    assert tx.is_coinbase()
    tx.tx_ins = [] # make not coinbase by deleting its inputs entirely
    assert not tx.is_coinbase()

def test_coinbase_height():

    raw = bytes.fromhex('0100000001813f79011acb80925dfe69b3def355fe914bd1d96a3f5f71bf8303c6a989c7d1000000006b483045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031ccfcf21320b0277457c98f02207a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9c8e10615bed01210349fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e213bf016b278afeffffff02a135ef01000000001976a914bc3b654dca7e56b04dca18f2566cdaf02e8d9ada88ac99c39800000000001976a9141c4bc762dd5423e332166702cb75f40df79fea1288ac19430600')
    tx = Tx.decode(BytesIO(raw))
    assert tx.coinbase_height() is None

    raw = bytes.fromhex('01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff5e03d71b07254d696e656420627920416e74506f6f6c20626a31312f4542312f4144362f43205914293101fabe6d6d678e2c8c34afc36896e7d9402824ed38e856676ee94bfdb0c6c4bcd8b2e5666a0400000000000000c7270000a5e00e00ffffffff01faf20b58000000001976a914338c84849423992471bffb1a54a8d9b1d69dc28a88ac00000000')
    tx = Tx.decode(BytesIO(raw))
    assert tx.coinbase_height() == 465879

```


## Content of bitcoin.py

```python
"""
Bitcoin-specific functions, classes, utilities and parameters
"""

from dataclasses import dataclass
from .curves import Curve, Point, Generator

# -----------------------------------------------------------------------------
# public API
__all__ = ['BITCOIN']

# -----------------------------------------------------------------------------

@dataclass
class Coin:
    gen: Generator

# -----------------------------------------------------------------------------

def bitcoin_gen():
    # Bitcoin uses secp256k1: http://www.oid-info.com/get/1.3.132.0.10
    p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
    a = 0x0000000000000000000000000000000000000000000000000000000000000000
    b = 0x0000000000000000000000000000000000000000000000000000000000000007
    Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
    Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
    n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
    curve = Curve(p, a, b)
    G = Point(curve, Gx, Gy)
    gen = Generator(G, n)
    return gen

# create an object that can be imported from other modules
BITCOIN = Coin(bitcoin_gen())

```


## Content of transaction.py

```python
"""
The Transaction object in Bitcoin
Reference: https://en.bitcoin.it/wiki/Transaction
"""

from __future__ import annotations # PEP 563: Postponed Evaluation of Annotations
from dataclasses import dataclass
from typing import Dict, List, Tuple, Union

import os
import requests
import string
from io import BytesIO

from .sha256 import sha256
from .ripemd160 import ripemd160
from .ecdsa import verify, Signature
from .keys import PublicKey

# -----------------------------------------------------------------------------
# helper functions

def decode_int(s, nbytes, encoding='little'):
    return int.from_bytes(s.read(nbytes), encoding)

def encode_int(i, nbytes, encoding='little'):
    return i.to_bytes(nbytes, encoding)

def decode_varint(s):
    i = decode_int(s, 1)
    if i == 0xfd:
        return decode_int(s, 2)
    elif i == 0xfe:
        return decode_int(s, 4)
    elif i == 0xff:
        return decode_int(s, 8)
    else:
        return i

def encode_varint(i):
    if i < 0xfd:
        return bytes([i])
    elif i < 0x10000:
        return b'\xfd' + encode_int(i, 2)
    elif i < 0x100000000:
        return b'\xfe' + encode_int(i, 4)
    elif i < 0x10000000000000000:
        return b'\xff' + encode_int(i, 8)
    else:
        raise ValueError("integer too large: %d" % (i, ))

# -----------------------------------------------------------------------------

class TxFetcher:
    """ lazily fetches transactions using an api on demand """

    @staticmethod
    def fetch(tx_id: str, net: str):
        assert isinstance(tx_id, str)
        assert all(c in string.hexdigits for c in tx_id)
        tx_id = tx_id.lower() # normalize just in case we get caps
        txdb_dir = 'txdb'
        cache_file = os.path.join(txdb_dir, tx_id)

        # cache transactions on disk so we're not stressing the generous API provider
        if os.path.isfile(cache_file):
            # fetch bytes from local disk store
            # print("reading transaction %s from disk cache" % (tx_id, ))
            with open(cache_file, 'rb') as f:
                raw = f.read()
        else:
            # fetch bytes from api
            # print("fetching transaction %s from API" % (tx_id, ))
            assert net is not None, "can't fetch a transaction without knowing which net to look at, e.g. main|test"
            if net == 'main':
                url = 'https://blockstream.info/api/tx/%s/hex' % (tx_id, )
            elif net == 'test':
                url = 'https://blockstream.info/testnet/api/tx/%s/hex' % (tx_id, )
            else:
                raise ValueError("%s is not a valid net type, should be main|test" % (net, ))
            response = requests.get(url)
            assert response.status_code == 200, "transaction id %s was not found on blockstream" % (tx_id, )
            raw = bytes.fromhex(response.text.strip())
            # cache on disk
            if not os.path.isdir(txdb_dir):
                os.makedirs(txdb_dir, exist_ok=True)
            with open(cache_file, 'wb') as f:
                f.write(raw)

        tx = Tx.decode(BytesIO(raw))
        assert tx.id() == tx_id # ensure that the calculated id matches the request id
        return tx


@dataclass
class Tx:
    version: int
    tx_ins: List[TxIn]
    tx_outs: List[TxOut]
    locktime: int = 0
    segwit: bool = False

    @classmethod
    def decode(cls, s):
        """ s is a stream of bytes, e.g. BytesIO(b'...') """
        # decode version
        version = decode_int(s, 4)
        # decode inputs + detect segwit transactions
        segwit = False
        num_inputs = decode_varint(s)
        if num_inputs == 0: # detect segwit marker b'\x00'
            assert s.read(1) == b'\x01' # assert segwit flag
            num_inputs = decode_varint(s) # override num_inputs
            segwit = True
        inputs = []
        for _ in range(num_inputs):
            inputs.append(TxIn.decode(s))
        # decode outputs
        num_outputs = decode_varint(s)
        outputs = []
        for _ in range(num_outputs):
            outputs.append(TxOut.decode(s))
        # decode witness in the case of segwit
        if segwit:
            for tx_in in inputs:
                num_items = decode_varint(s)
                items = []
                for _ in range(num_items):
                    item_len = decode_varint(s)
                    if item_len == 0:
                        items.append(0)
                    else:
                        items.append(s.read(item_len))
                tx_in.witness = items
        # decode locktime
        locktime = decode_int(s, 4)
        return cls(version, inputs, outputs, locktime, segwit)

    def encode(self, force_legacy=False, sig_index=-1) -> bytes:
        """
        encode this transaction as bytes.
        If sig_index is given then return the modified transaction
        encoding of this tx with respect to the single input index.
        This result then constitutes the "message" that gets signed
        by the aspiring transactor of this input.
        """
        out = []
        # encode metadata
        out += [encode_int(self.version, 4)]
        if self.segwit and not force_legacy:
            out += [b'\x00\x01'] # segwit marker + flag bytes
        # encode inputs
        out += [encode_varint(len(self.tx_ins))]
        if sig_index == -1:
            out += [tx_in.encode() for tx_in in self.tx_ins]
        else:
            out += [tx_in.encode(script_override=(sig_index == i))
                    for i, tx_in in enumerate(self.tx_ins)]
        # encode outputs
        out += [encode_varint(len(self.tx_outs))]
        out += [tx_out.encode() for tx_out in self.tx_outs]
        # encode witnesses
        if self.segwit and not force_legacy:
            for tx_in in self.tx_ins:
                out += [encode_varint(len(tx_in.witness))] # num_items
                for item in tx_in.witness:
                    if isinstance(item, int):
                        out += [encode_varint(item)]
                    else: # bytes
                        out += [encode_varint(len(item)), item]
        # encode... other metadata I guess
        out += [encode_int(self.locktime, 4)]
        out += [encode_int(1, 4) if sig_index != -1 else b''] # 1 = SIGHASH_ALL
        return b''.join(out)

    def id(self) -> str:
        return sha256(sha256(self.encode(force_legacy=True)))[::-1].hex()

    def fee(self) -> int:
        input_total = sum(tx_in.value() for tx_in in self.tx_ins)
        output_total = sum(tx_out.amount for tx_out in self.tx_outs)
        return input_total - output_total

    def validate(self):
        assert not self.segwit # todo for segwits

        # validate that this transaction is not minting coins
        if self.fee() < 0:
            return False

        # validate the digital signatures of all inputs
        for i, tx in enumerate(self.tx_ins):
            """
            note: here we should be decoding the sighash-type, which is the
            last byte appended on top of the DER signature in the script_sig,
            and encoding the signing bytes accordingly. For now we assume the
            most common type of signature, which is 1 = SIGHASH_ALL
            """
            mod_tx_enc = self.encode(sig_index=i)
            combined = tx.script_sig + tx.script_pubkey() # Script addition
            valid = combined.evaluate(mod_tx_enc)
            if not valid:
                return False

        return True

    def is_coinbase(self) -> bool:
        return (len(self.tx_ins) == 1) and \
               (self.tx_ins[0].prev_tx == b'\x00'*32) and \
               (self.tx_ins[0].prev_index == 0xffffffff)

    def coinbase_height(self) -> int:
        """ returns the block number of a given transaction, following BIP0034 """
        return int.from_bytes(self.tx_ins[0].script_sig.cmds[0], 'little') if self.is_coinbase() else None


@dataclass
class TxIn:
    prev_tx: bytes # prev transaction ID: hash256 of prev tx contents
    prev_index: int # UTXO output index in the transaction
    script_sig: Script = None # unlocking script
    sequence: int = 0xffffffff # originally intended for "high frequency trades", with locktime
    witness: List[bytes] = None
    net: str = None # which net are we on? eg 'main'|'test'

    @classmethod
    def decode(cls, s):
        prev_tx = s.read(32)[::-1] # 32 bytes little endian
        prev_index = decode_int(s, 4)
        script_sig = Script.decode(s)
        sequence = decode_int(s, 4)
        return cls(prev_tx, prev_index, script_sig, sequence)

    def encode(self, script_override=None):
        out = []
        out += [self.prev_tx[::-1]]
        out += [encode_int(self.prev_index, 4)]

        if script_override is None:
            # None = just use the actual script
            out += [self.script_sig.encode()]
        elif script_override is True:
            # True = override the script with the script_pubkey of the associated input
            tx = TxFetcher.fetch(self.prev_tx.hex(), net=self.net)
            out += [tx.tx_outs[self.prev_index].script_pubkey.encode()]
        elif script_override is False:
            # False = override with an empty script
            out += [Script([]).encode()]
        else:
            raise ValueError("script_override must be one of None|True|False")

        out += [encode_int(self.sequence, 4)]
        return b''.join(out)

    def value(self):
        # look the amount up on the previous transaction
        tx = TxFetcher.fetch(self.prev_tx.hex(), net=self.net)
        amount = tx.tx_outs[self.prev_index].amount
        return amount

    def script_pubkey(self):
        # look the script_pubkey up on the previous transaction
        tx = TxFetcher.fetch(self.prev_tx.hex(), net=self.net)
        script = tx.tx_outs[self.prev_index].script_pubkey
        return script


@dataclass
class TxOut:
    amount: int # in units of satoshi (1e-8 of a bitcoin)
    script_pubkey: Script # locking script

    @classmethod
    def decode(cls, s):
        amount = decode_int(s, 8)
        script_pubkey = Script.decode(s)
        return cls(amount, script_pubkey)

    def encode(self):
        out = []
        out += [encode_int(self.amount, 8)]
        out += [self.script_pubkey.encode()]
        return b''.join(out)


@dataclass
class Script:
    cmds: List[Union[int, bytes]]

    def __repr__(self):
        repr_int = lambda cmd: OP_CODE_NAMES.get(cmd, 'OP_[{}]'.format(cmd))
        repr_bytes = lambda cmd: cmd.hex()
        repr_cmd = lambda cmd: repr_int(cmd) if isinstance(cmd, int) else repr_bytes(cmd)
        return ' '.join(map(repr_cmd, self.cmds))

    @classmethod
    def decode(cls, s):
        length = decode_varint(s)
        cmds = []
        count = 0 # number of bytes read
        while count < length:
            current = s.read(1)[0] # read current byte as integer
            count += 1
            # push commands onto stack, elements as bytes or ops as integers
            if 1 <= current <= 75:
                # elements of size [1, 75] bytes
                cmds.append(s.read(current))
                count += current
            elif current == 76:
                # op_pushdata1: elements of size [76, 255] bytes
                data_length = decode_int(s, 1)
                cmds.append(s.read(data_length))
                count += data_length + 1
            elif current == 77:
                # op_pushdata2: elements of size [256-520] bytes
                data_length = decode_int(s, 2)
                cmds.append(s.read(data_length))
                count += data_length + 2
            else:
                # represents an op_code, add it (as int)
                cmds.append(current)
        if count != length:
            raise SyntaxError('parsing script failed')
        return cls(cmds)

    def encode(self):
        out = []
        for cmd in self.cmds:
            if isinstance(cmd, int):
                # an int is just an opcode, encode as a single byte
                out += [encode_int(cmd, 1)]
            else:
                # bytes represent an element, encode its length and then content
                length = len(cmd) # in bytes
                if length < 75:
                    out += [encode_int(length, 1)]
                elif 76 <= length <= 255:
                    out += [encode_int(76, 1), encode_int(length, 1)] # pushdata1
                elif 256 <= length <= 520:
                    out += [encode_int(77, 1), encode_int(length, 2)] # pushdata2
                else:
                    raise ValueError("cmd of length %d bytes is too long?" % (length, ))
                out += [cmd]
        ret = b''.join(out)
        return encode_varint(len(ret)) + ret

    def evaluate(self, mod_tx_enc):

        # for now let's just support a standard p2pkh transaction
        assert len(self.cmds) == 7
        assert isinstance(self.cmds[0], bytes) # signature
        assert isinstance(self.cmds[1], bytes) # pubkey
        assert isinstance(self.cmds[2], int) and (OP_CODE_NAMES[self.cmds[2]] == 'OP_DUP')
        assert isinstance(self.cmds[3], int) and (OP_CODE_NAMES[self.cmds[3]] == 'OP_HASH160')
        assert isinstance(self.cmds[4], bytes) # hash
        assert isinstance(self.cmds[5], int) and (OP_CODE_NAMES[self.cmds[5]] == 'OP_EQUALVERIFY')
        assert isinstance(self.cmds[6], int) and (OP_CODE_NAMES[self.cmds[6]] == 'OP_CHECKSIG')

        # verify the public key hash, answering the OP_EQUALVERIFY challenge
        pubkey, pubkey_hash = self.cmds[1], self.cmds[4]
        if pubkey_hash != ripemd160(sha256(pubkey)):
            return False

        # verify the digital signature of the transaction, answering the OP_CHECKSIG challenge
        sighash_type = self.cmds[0][-1] # the last byte is the sighash type
        assert sighash_type == 1 # 1 is SIGHASH_ALL, most commonly used and only one supported right now
        der = self.cmds[0][:-1] # DER encoded signature, but crop out the last byte
        sec = self.cmds[1] # SEC encoded public key
        sig = Signature.decode(der)
        pk = PublicKey.decode(sec)
        valid = verify(pk, mod_tx_enc, sig)

        return valid

    def __add__(self, other):
        return Script(self.cmds + other.cmds)


OP_CODE_NAMES = {
    0: 'OP_0',
    # values 1..75 are not opcodes but indicate elements
    76: 'OP_PUSHDATA1',
    77: 'OP_PUSHDATA2',
    78: 'OP_PUSHDATA4',
    79: 'OP_1NEGATE',
    81: 'OP_1',
    82: 'OP_2',
    83: 'OP_3',
    84: 'OP_4',
    85: 'OP_5',
    86: 'OP_6',
    87: 'OP_7',
    88: 'OP_8',
    89: 'OP_9',
    90: 'OP_10',
    91: 'OP_11',
    92: 'OP_12',
    93: 'OP_13',
    94: 'OP_14',
    95: 'OP_15',
    96: 'OP_16',
    97: 'OP_NOP',
    99: 'OP_IF',
    100: 'OP_NOTIF',
    103: 'OP_ELSE',
    104: 'OP_ENDIF',
    105: 'OP_VERIFY',
    106: 'OP_RETURN',
    107: 'OP_TOALTSTACK',
    108: 'OP_FROMALTSTACK',
    109: 'OP_2DROP',
    110: 'OP_2DUP',
    111: 'OP_3DUP',
    112: 'OP_2OVER',
    113: 'OP_2ROT',
    114: 'OP_2SWAP',
    115: 'OP_IFDUP',
    116: 'OP_DEPTH',
    117: 'OP_DROP',
    118: 'OP_DUP',
    119: 'OP_NIP',
    120: 'OP_OVER',
    121: 'OP_PICK',
    122: 'OP_ROLL',
    123: 'OP_ROT',
    124: 'OP_SWAP',
    125: 'OP_TUCK',
    130: 'OP_SIZE',
    135: 'OP_EQUAL',
    136: 'OP_EQUALVERIFY',
    139: 'OP_1ADD',
    140: 'OP_1SUB',
    143: 'OP_NEGATE',
    144: 'OP_ABS',
    145: 'OP_NOT',
    146: 'OP_0NOTEQUAL',
    147: 'OP_ADD',
    148: 'OP_SUB',
    154: 'OP_BOOLAND',
    155: 'OP_BOOLOR',
    156: 'OP_NUMEQUAL',
    157: 'OP_NUMEQUALVERIFY',
    158: 'OP_NUMNOTEQUAL',
    159: 'OP_LESSTHAN',
    160: 'OP_GREATERTHAN',
    161: 'OP_LESSTHANOREQUAL',
    162: 'OP_GREATERTHANOREQUAL',
    163: 'OP_MIN',
    164: 'OP_MAX',
    165: 'OP_WITHIN',
    166: 'OP_RIPEMD160',
    167: 'OP_SHA1',
    168: 'OP_SHA256',
    169: 'OP_HASH160',
    170: 'OP_HASH256',
    171: 'OP_CODESEPARATOR',
    172: 'OP_CHECKSIG',
    173: 'OP_CHECKSIGVERIFY',
    174: 'OP_CHECKMULTISIG',
    175: 'OP_CHECKMULTISIGVERIFY',
    176: 'OP_NOP1',
    177: 'OP_CHECKLOCKTIMEVERIFY',
    178: 'OP_CHECKSEQUENCEVERIFY',
    179: 'OP_NOP4',
    180: 'OP_NOP5',
    181: 'OP_NOP6',
    182: 'OP_NOP7',
    183: 'OP_NOP8',
    184: 'OP_NOP9',
    185: 'OP_NOP10',
}

```


## Content of sha256.py

```python
"""
Follows the FIPS PUB 180-4 description for calculating SHA-256 hash function
https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf

Noone in their right mind should use this for any serious reason. This was written
purely for educational purposes.
"""

import math
from itertools import count, islice

# -----------------------------------------------------------------------------
# SHA-256 Functions, defined in Section 4

def rotr(x, n, size=32):
    return (x >> n) | (x << size - n) & (2**size - 1)

def shr(x, n):
    return x >> n

def sig0(x):
    return rotr(x, 7) ^ rotr(x, 18) ^ shr(x, 3)

def sig1(x):
    return rotr(x, 17) ^ rotr(x, 19) ^ shr(x, 10)

def capsig0(x):
    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22)

def capsig1(x):
    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25)

def ch(x, y, z):
    return (x & y)^ (~x & z)

def maj(x, y, z):
    return (x & y) ^ (x & z) ^ (y & z)

def b2i(b):
    return int.from_bytes(b, 'big')

def i2b(i):
    return i.to_bytes(4, 'big')

# -----------------------------------------------------------------------------
# SHA-256 Constants

def is_prime(n):
    return not any(f for f in range(2,int(math.sqrt(n))+1) if n%f == 0)

def first_n_primes(n):
    return islice(filter(is_prime, count(start=2)), n)

def frac_bin(f, n=32):
    """ return the first n bits of fractional part of float f """
    f -= math.floor(f) # get only the fractional part
    f *= 2**n # shift left
    f = int(f) # truncate the rest of the fractional content
    return f

def genK():
    """
    Follows Section 4.2.2 to generate K

    The first 32 bits of the fractional parts of the cube roots of the first
    64 prime numbers:

    428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5
    d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174
    e49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da
    983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967
    27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85
    a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070
    19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
    748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2
    """
    return [frac_bin(p ** (1/3.0)) for p in first_n_primes(64)]

def genH():
    """
    Follows Section 5.3.3 to generate the initial hash value H^0

    The first 32 bits of the fractional parts of the square roots of
    the first 8 prime numbers.

    6a09e667 bb67ae85 3c6ef372 a54ff53a 9b05688c 510e527f 1f83d9ab 5be0cd19
    """
    return [frac_bin(p ** (1/2.0)) for p in first_n_primes(8)]

# -----------------------------------------------------------------------------

def pad(b):
    """ Follows Section 5.1: Padding the message """
    b = bytearray(b) # convert to a mutable equivalent
    l = len(b) * 8 # note: len returns number of bytes not bits

    # append but "1" to the end of the message
    b.append(0b10000000) # appending 10000000 in binary (=128 in decimal)

    # follow by k zero bits, where k is the smallest non-negative solution to
    # l + 1 + k = 448 mod 512
    # i.e. pad with zeros until we reach 448 (mod 512)
    while (len(b)*8) % 512 != 448:
        b.append(0x00)

    # the last 64-bit block is the length l of the original message
    # expressed in binary (big endian)
    b.extend(l.to_bytes(8, 'big'))

    return b

def sha256(b: bytes) -> bytes:

    # Section 4.2
    K = genK()

    # Section 5: Preprocessing
    # Section 5.1: Pad the message
    b = pad(b)
    # Section 5.2: Separate the message into blocks of 512 bits (64 bytes)
    blocks = [b[i:i+64] for i in range(0, len(b), 64)]

    # for each message block M^1 ... M^N
    H = genH() # Section 5.3

    # Section 6
    for M in blocks: # each block is a 64-entry array of 8-bit bytes

        # 1. Prepare the message schedule, a 64-entry array of 32-bit words
        W = []
        for t in range(64):
            if t <= 15:
                # the first 16 words are just a copy of the block
                W.append(bytes(M[t*4:t*4+4]))
            else:
                term1 = sig1(b2i(W[t-2]))
                term2 = b2i(W[t-7])
                term3 = sig0(b2i(W[t-15]))
                term4 = b2i(W[t-16])
                total = (term1 + term2 + term3 + term4) % 2**32
                W.append(i2b(total))

        # 2. Initialize the 8 working variables a,b,c,d,e,f,g,h with prev hash value
        a, b, c, d, e, f, g, h = H

        # 3.
        for t in range(64):
            T1 = (h + capsig1(e) + ch(e, f, g) + K[t] + b2i(W[t])) % 2**32
            T2 = (capsig0(a) + maj(a, b, c)) % 2**32
            h = g
            g = f
            f = e
            e = (d + T1) % 2**32
            d = c
            c = b
            b = a
            a = (T1 + T2) % 2**32

        # 4. Compute the i-th intermediate hash value H^i
        delta = [a, b, c, d, e, f, g, h]
        H = [(i1 + i2) % 2**32 for i1, i2 in zip(H, delta)]

    return b''.join(i2b(i) for i in H)

if __name__ == '__main__':
    import sys
    assert len(sys.argv) == 2, "Pass in exactly one filename to return checksum of"
    with open(sys.argv[1], 'rb') as f:
        print(sha256(f.read()).hex())

```


## Content of __init__.py

```python

```


## Content of keys.py

```python
"""
Utilities to generate secret/public key pairs and Bitcoin address
(note: using "secret" instead of "private" so that sk and pk are
easy consistent shortcuts of the two without collision)
"""

import os
import time

from .curves import Point
from .bitcoin import BITCOIN
from .sha256 import sha256
from .ripemd160 import ripemd160

# -----------------------------------------------------------------------------
# Secret key generation. We're going to leave secret key as just a super plain int

def gen_secret_key(n: int) -> int:
    """
    n is the upper bound on the key, typically the order of the elliptic curve
    we are using. The function will return a valid key, i.e. 1 <= key < n.
    """
    while True:
        key = int.from_bytes(os.urandom(32), 'big')
        if 1 <= key < n:
            break # the key is valid, break out
    return key

# -----------------------------------------------------------------------------
# Public key - specific functions, esp encoding / decoding

class PublicKey(Point):
    """
    The public key is just a Point on a Curve, but has some additional specific
    encoding / decoding functionality that this class implements.
    """

    @classmethod
    def from_point(cls, pt: Point):
        """ promote a Point to be a PublicKey """
        return cls(pt.curve, pt.x, pt.y)

    @classmethod
    def from_sk(cls, sk):
        """ sk can be an int or a hex string """
        assert isinstance(sk, (int, str))
        sk = int(sk, 16) if isinstance(sk, str) else sk
        pk = sk * BITCOIN.gen.G
        return cls.from_point(pk)

    @classmethod
    def decode(cls, b: bytes):
        """ decode from the SEC binary format """
        assert isinstance(b, bytes)

        # the uncompressed version is straight forward
        if b[0] == 4:
            x = int.from_bytes(b[1:33], 'big')
            y = int.from_bytes(b[33:65], 'big')
            return Point(BITCOIN.gen.G.curve, x, y)

        # for compressed version uncompress the full public key Point
        # first recover the y-evenness and the full x
        assert b[0] in [2, 3]
        is_even = b[0] == 2
        x = int.from_bytes(b[1:], 'big')

        # solve y^2 = x^3 + 7 for y, but mod p
        p = BITCOIN.gen.G.curve.p
        y2 = (pow(x, 3, p) + 7) % p
        y = pow(y2, (p + 1) // 4, p)
        y = y if ((y % 2 == 0) == is_even) else p - y # flip if needed to make the evenness agree
        return cls(BITCOIN.gen.G.curve, x, y)

    def encode(self, compressed, hash160=False):
        """ return the SEC bytes encoding of the public key Point """
        # calculate the bytes
        if compressed:
            prefix = b'\x02' if self.y % 2 == 0 else b'\x03'
            pkb = prefix + self.x.to_bytes(32, 'big')
        else:
            pkb = b'\x04' + self.x.to_bytes(32, 'big') + self.y.to_bytes(32, 'big')
        # hash if desired
        return ripemd160(sha256(pkb)) if hash160 else pkb

    def address(self, net: str, compressed: bool) -> str:
        """ return the associated bitcoin address for this public key as string """
        # encode the public key into bytes and hash to get the payload
        pkb_hash = self.encode(compressed=compressed, hash160=True)
        # add version byte (0x00 for Main Network, or 0x6f for Test Network)
        version = {'main': b'\x00', 'test': b'\x6f'}
        ver_pkb_hash = version[net] + pkb_hash
        # calculate the checksum
        checksum = sha256(sha256(ver_pkb_hash))[:4]
        # append to form the full 25-byte binary Bitcoin Address
        byte_address = ver_pkb_hash + checksum
        # finally b58 encode the result
        b58check_address = b58encode(byte_address)
        return b58check_address

# -----------------------------------------------------------------------------
# convenience functions

def gen_key_pair():
    """ generate a (secret, public) key pair in one shot """
    sk = gen_secret_key(BITCOIN.gen.n)
    pk = PublicKey.from_sk(sk)
    return sk, pk

# -----------------------------------------------------------------------------
# base58 encoding / decoding utilities
# reference: https://en.bitcoin.it/wiki/Base58Check_encoding

alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
alphabet_inv = {c:i for i,c in enumerate(alphabet)}

def b58encode(b: bytes) -> str:
    assert len(b) == 25 # version is 1 byte, pkb_hash 20 bytes, checksum 4 bytes
    n = int.from_bytes(b, 'big')
    chars = []
    while n:
        n, i = divmod(n, 58)
        chars.append(alphabet[i])
    # special case handle the leading 0 bytes... ¯\_(ツ)_/¯
    num_leading_zeros = len(b) - len(b.lstrip(b'\x00'))
    res = num_leading_zeros * alphabet[0] + ''.join(reversed(chars))
    return res

def b58decode(res: str) -> bytes:
    n = sum(alphabet_inv[c] * 58**i for i, c in enumerate(reversed(res)))
    return n.to_bytes(25, 'big') # version, pkb_hash, checksum bytes

def address_to_pkb_hash(b58check_address: str) -> bytes:
    """ given an address in b58check recover the public key hash """
    byte_address = b58decode(b58check_address)
    # validate the checksum
    assert byte_address[-4:] == sha256(sha256(byte_address[:-4]))[:4]
    # strip the version in front and the checksum at tail
    pkb_hash = byte_address[1:-4]
    return pkb_hash

```


## Content of ecdsa.py

```python
"""
Elliptic Curve Digital Signature Algorithm (ECDSA)
Functions that sign/verify digital signatures and related utilities
"""

from dataclasses import dataclass
from io import BytesIO

from .sha256 import sha256
from cryptos.bitcoin import BITCOIN
from cryptos.curves import inv, Point
from cryptos.keys import gen_secret_key, PublicKey
# -----------------------------------------------------------------------------

@dataclass
class Signature:
    r: int
    s: int

    @classmethod
    def decode(cls, der: bytes):
        """
        According to https://en.bitcoin.it/wiki/BIP_0062#DER_encoding DER has the following format:
        0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash-type]

        total-length: 1-byte length descriptor of everything that follows, excluding the sighash byte.
        R-length: 1-byte length descriptor of the R value that follows.
        R: arbitrary-length big-endian encoded R value. It cannot start with any 0x00 bytes, unless the first byte that follows is 0x80 or higher, in which case a single 0x00 is required.
        S-length: 1-byte length descriptor of the S value that follows.
        S: arbitrary-length big-endian encoded S value. The same rules apply as for R.
        sighash-type: 1-byte hashtype flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed).

        NOTE: the sighash type is just appended at the end of the DER signature at the end in
        Bitcoin transactions, and isn't actually part of the DER signature. Here we already assume
        it has been cropped out.
        """
        s = BytesIO(der)
        assert s.read(1)[0] == 0x30
        # read and validate the total length of the encoding
        length = s.read(1)[0]
        assert length == len(der) - 2 # -2 to exclude 1) the starting 0x30, 2) total-length byte
        assert s.read(1)[0] == 0x02
        # read r
        rlength = s.read(1)[0]
        rval = int.from_bytes(s.read(rlength), 'big')
        assert s.read(1)[0] == 0x02
        # read s
        slength = s.read(1)[0]
        sval = int.from_bytes(s.read(slength), 'big')
        # validate total length and return
        assert len(der) == 6 + rlength + slength # 6 is the sum of misc / metadata bytes in the DER signature
        return cls(rval, sval)

    def encode(self) -> bytes:
        """ return the DER encoding of this signature """

        def dern(n):
            nb = n.to_bytes(32, byteorder='big')
            nb = nb.lstrip(b'\x00') # strip leading zeros
            nb = (b'\x00' if nb[0] >= 0x80 else b'') + nb # preprend 0x00 if first byte >= 0x80
            return nb

        rb = dern(self.r)
        sb = dern(self.s)
        content = b''.join([bytes([0x02, len(rb)]), rb, bytes([0x02, len(sb)]), sb])
        frame = b''.join([bytes([0x30, len(content)]), content])
        return frame

def sign(secret_key: int, message: bytes) -> Signature:

    n = BITCOIN.gen.n

    # hash the message and convert to integer
    # TODO: do we want to do this here? or outside? probably not here
    z = int.from_bytes(sha256(sha256(message)), 'big')

    # generate a new secret/public key pair at random
    # TODO: make deterministic
    # TODO: make take constant time to mitigate timing attacks
    k = gen_secret_key(n)
    P = PublicKey.from_sk(k)

    # calculate the signature
    r = P.x
    s = inv(k, n) * (z + secret_key * r) % n
    if s > n / 2:
        s = n - s

    sig = Signature(r, s)
    return sig

def verify(public_key: Point, message: bytes, sig: Signature) -> bool:

    n = BITCOIN.gen.n

    # some super basic verification
    assert isinstance(sig.r, int) and 1 <= sig.r < n
    assert isinstance(sig.s, int) and 1 <= sig.s < n

    # hash the message and convert to integer
    z = int.from_bytes(sha256(sha256(message)), 'big')

    # verify signature
    w = inv(sig.s, n)
    u1 = z * w % n
    u2 = sig.r * w % n
    P = (u1 * BITCOIN.gen.G) + (u2 * public_key)
    match = P.x == sig.r

    return match


```


## Content of network.py

```python
"""
Classes/utils for connecting to Bitcoin nodes

Protocol Documentation: https://en.bitcoin.it/wiki/Protocol_documentation
"""

from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Union

import socket
from io import BytesIO

from .sha256 import sha256
from .transaction import encode_varint, decode_varint
from .block import Block

# -----------------------------------------------------------------------------

MAGICS = {
    'main': b'\xf9\xbe\xb4\xd9',
    'test': b'\x0b\x11\x09\x07',
}

@dataclass
class NetworkEnvelope:
    command: bytes
    payload: bytes
    net: str

    def __repr__(self):
        return "[NetworkEnvelope] Command: %s, Payload: %s" % \
               (self.command.decode('ascii'), self.payload.hex())

    @classmethod
    def decode(cls, s, net):
        """ Construct a NetworkEnvelope from BytesIO stream s on a given net """

        # validate magic bytes
        magic = s.read(4)
        assert magic != b'', "No magic bytes; Connection was reset?"
        assert magic == MAGICS[net]
        # decode the command
        command = s.read(12)
        command = command.strip(b'\x00')
        # decode and validate the payload
        payload_length = int.from_bytes(s.read(4), 'little')
        checksum = s.read(4)
        payload = s.read(payload_length)
        assert checksum == sha256(sha256(payload))[:4]

        return cls(command, payload, net)

    def encode(self):
        """ Encode this network message as bytes """
        out = []

        out += [MAGICS[self.net]]
        # encode the command
        assert len(self.command) <= 12
        out += [self.command]
        out += [b'\x00' * (12 - len(self.command))] # command padding
        # encode the payload
        assert len(self.payload) <= 2**32 # in practice reference client nodes will reject >= 32MB...
        out += [len(self.payload).to_bytes(4, 'little')] # payload length
        out += [sha256(sha256(self.payload))[:4]] # checksum
        out += [self.payload]

        return b''.join(out)

    def stream(self):
        """ Stream the payload of this envelope """
        return BytesIO(self.payload)

# -----------------------------------------------------------------------------
# Specific types of commands and their payload encoder/decords follow
# -----------------------------------------------------------------------------

@dataclass
class NetAddrStruct:
    """
    reference: https://en.bitcoin.it/wiki/Protocol_documentation#Network_address
    currently assumes IPv4 address
    """
    services: int = 0
    ip: bytes = b'\x00\x00\x00\x00' # IPv4 address
    port: int = 8333

    def encode(self):
        out = []
        # receiver services is 8 bytes little endian
        out += [self.services.to_bytes(8, 'little')]
        # IPV4 is 10 00 bytes and 2 ff bytes then receiver ip
        assert isinstance(self.ip, bytes) and len(self.ip) == 4
        out += [b'\x00' * 10 + b'\xff\xff' + self.ip]
        # receiver port is 2 bytes, big endian
        out += [self.port.to_bytes(2, 'big')]
        return b''.join(out)


@dataclass
class VersionMessage:
    """
    reference: https://en.bitcoin.it/wiki/Protocol_documentation#version
    When a node creates an outgoing connection, it will immediately advertise
    its version. The remote node will respond with its version. No further
    communication is possible until both peers have exchanged their version.
    """

    # header information
    version: int = 70015 # specifies what messages may be communicated
    services: int = 0 # info about what capabilities are available
    timestamp: int = None # 8 bytes Unix timestamp in little-endian
    # receiver net_addr
    receiver: NetAddrStruct = field(default_factory=NetAddrStruct)
    # sender net_addr
    sender: NetAddrStruct = field(default_factory=NetAddrStruct)
    # additional metadata
    """
    uint64_t Node random nonce, randomly generated every time a version
    packet is sent. This nonce is used to detect connections to self.
    """
    nonce: bytes = None # 8 bytes of nonce
    user_agent: bytes = None # var_str: User Agent
    latest_block: int = 0 # "The last block received by the emitting node"
    relay: bool = False # Whether the remote peer should announce relayed transactions or not, see BIP 0037
    command: str = field(init=False, default=b'version')

    @classmethod
    def decode(cls, s):
        # TODO. For now return a fixed default stub
        return cls()

    def encode(self):
        out = []

        # version is 4 bytes little endian
        out += [self.version.to_bytes(4, 'little')]
        # services is 8 bytes little endian
        out += [self.services.to_bytes(8, 'little')]
        # timestamp is 8 bytes little endian
        out += [self.timestamp.to_bytes(8, 'little')]
        # receiver
        out += [self.receiver.encode()]
        # sender
        out += [self.sender.encode()]
        # nonce should be 8 bytes
        assert isinstance(self.nonce, bytes) and len(self.nonce) == 8
        out += [self.nonce]
        # useragent is a variable string, so varint first
        assert isinstance(self.user_agent, bytes)
        out += [encode_varint(len(self.user_agent))]
        out += [self.user_agent]

        # latest block is 4 bytes little endian
        out += [self.latest_block.to_bytes(4, 'little')]
        # relay is 00 if false, 01 if true
        out += [b'\x01' if self.relay else b'\x00']

        return b''.join(out)

@dataclass
class VerAckMessage:
    """
    https://en.bitcoin.it/wiki/Protocol_documentation#verack
    The verack message is sent in reply to version. This message
    consists of only a message header with the command string "verack".
    """
    command: str = field(init=False, default=b'verack')

    @classmethod
    def decode(cls, s):
        return cls()

    def encode(self):
        return b''

@dataclass
class PingMessage:
    """
    https://en.bitcoin.it/wiki/Protocol_documentation#ping
    The ping message is sent primarily to confirm that the TCP/IP
    connection is still valid. An error in transmission is presumed
    to be a closed connection and the address is removed as a current peer.
    """
    nonce: bytes
    command: str = field(init=False, default=b'ping')

    @classmethod
    def decode(cls, s):
        nonce = s.read(8)
        return cls(nonce)

    def encode(self):
        return self.nonce

@dataclass
class PongMessage:
    """
    https://en.bitcoin.it/wiki/Protocol_documentation#pong
    The pong message is sent in response to a ping message.
    In modern protocol versions, a pong response is generated
    using a nonce included in the ping.
    """
    nonce: bytes
    command: str = field(init=False, default=b'pong')

    @classmethod
    def decode(cls, s):
        nonce = s.read(8)
        return cls(nonce)

    def encode(self):
        return self.nonce

@dataclass
class GetHeadersMessage:
    """
    https://en.bitcoin.it/wiki/Protocol_documentation#getheaders
    """
    version: int = 70015 # uint32_t protocol version
    num_hashes: int = 1 # var_int, number of block locator hash entries; can be >1 if there is a chain split
    start_block: bytes = None # char[32] block locator object
    end_block: bytes = None # char[32] hash of the last desired block header; set to zero to get as many blocks as possible
    command: str = field(init=False, default=b'getheaders')

    def __post_init__(self):
        assert isinstance(self.start_block, bytes) and len(self.start_block) == 32
        self.end_block = self.end_block if self.end_block is not None else b'\x00' * 32
        assert isinstance(self.end_block, bytes) and len(self.end_block) == 32

    def encode(self):
        out = []
        out += [self.version.to_bytes(4, 'little')]
        out += [encode_varint(self.num_hashes)]
        out += [self.start_block[::-1]] # little-endian
        out += [self.end_block[::-1]] # little-endian
        return b''.join(out)

@dataclass
class HeadersMessage:
    """
    https://en.bitcoin.it/wiki/Protocol_documentation#headers
    """
    blocks: List[Block] = None
    command: str = field(init=False, default=b'headers')

    @classmethod
    def decode(cls, s):
        count = decode_varint(s)
        blocks = []
        for _ in range(count):
            b = Block.decode(s)
            blocks.append(b)
            """
            the number of transactions is also given and is always zero if we
            only request the headers. This is done so that the same code can be
            used to decode the "block" message, which contains the full block
            information with all the transactions attached. Here we just make
            sure it is zero.
            """
            num_transactions = decode_varint(s)
            assert num_transactions == 0
        return cls(blocks)

# -----------------------------------------------------------------------------
# A super lightweight baby node follows
# -----------------------------------------------------------------------------

class SimpleNode:

    def __init__(self, host: str, net: str, verbose: int = 0):
        self.net = net
        self.verbose = verbose

        port = {'main': 8333, 'test': 18333}[net]
        self.socket = socket.socket()
        self.socket.connect((host, port))
        self.stream = self.socket.makefile('rb', None)

    def send(self, message):
        env = NetworkEnvelope(message.command, message.encode(), net=self.net)
        if self.verbose:
            print(f"sending: {env}")
        self.socket.sendall(env.encode())

    def read(self):
        env = NetworkEnvelope.decode(self.stream, net=self.net)
        if self.verbose:
            print(f"receiving: {env}")
        return env

    def wait_for(self, *message_classes):
        command = None
        command_to_class = { m.command: m for m in message_classes }

        # loop until one of the desired commands is encountered
        while command not in command_to_class:
            env = self.read()
            command = env.command

            # respond to Version with VerAck
            if command == VersionMessage.command:
                self.send(VerAckMessage())

            # respond to Ping with Pong
            elif command == PingMessage.command:
                self.send(PongMessage(env.payload))

        # return the parsed message
        return command_to_class[command].decode(env.stream())

    def handshake(self):
        """
        Version Handshake
        ref: https://en.bitcoin.it/wiki/Version_Handshake

        Local peer (L) connects to a remote peer (R):
        L -> R: Send version message with the local peer's version
        R -> L: Send version message back
        R -> L: Send verack message
        R:      Sets version to the minimum of the 2 versions
        L -> R: Send verack message after receiving version message from R
        L:      Sets version to the minimum of the 2 versions
        """
        version = VersionMessage(
            timestamp=0,
            nonce=b'\x00'*8,
            user_agent=b'/programmingbitcoin:0.1/',
        )
        self.send(version)
        self.wait_for(VersionMessage)
        self.wait_for(VerAckMessage)
        self.send(VerAckMessage())

    def close(self):
        self.socket.close()

```


## Content of curves.py

```python
"""
Core functions for math over Elliptic Curves over Finite Fields,
especially the ability to define Points on Curves and perform
addition and scalar multiplication.
"""

from __future__ import annotations # PEP 563: Postponed Evaluation of Annotations
from dataclasses import dataclass

# -----------------------------------------------------------------------------
# public API

__all__ = ['Curve', 'Point', 'Generator']

# -----------------------------------------------------------------------------
# Related math utilities

def extended_euclidean_algorithm(a, b):
    """
    Returns (gcd, x, y) s.t. a * x + b * y == gcd
    This function implements the extended Euclidean
    algorithm and runs in O(log b) in the worst case,
    taken from Wikipedia.
    """
    old_r, r = a, b
    old_s, s = 1, 0
    old_t, t = 0, 1
    while r != 0:
        quotient = old_r // r
        old_r, r = r, old_r - quotient * r
        old_s, s = s, old_s - quotient * s
        old_t, t = t, old_t - quotient * t
    return old_r, old_s, old_t

def inv(n, p):
    """ returns modular multiplicate inverse m s.t. (n * m) % p == 1 """
    gcd, x, y = extended_euclidean_algorithm(n, p) # pylint: disable=unused-variable
    return x % p

# -----------------------------------------------------------------------------
# Core data structures to represent curves and generators

@dataclass
class Curve:
    """
    Elliptic Curve over the field of integers modulo a prime.
    Points on the curve satisfy y^2 = x^3 + a*x + b (mod p).
    """
    p: int
    a: int
    b: int

@dataclass
class Point:
    """ An integer point (x,y) on a Curve """
    curve: Curve
    x: int
    y: int

    def __add__(self, other: Point) -> Point:
        # handle special case of P + 0 = 0 + P = 0
        if self == INF:
            return other
        if other == INF:
            return self
        # handle special case of P + (-P) = 0
        if self.x == other.x and self.y != other.y:
            return INF
        # compute the "slope"
        if self.x == other.x: # (self.y = other.y is guaranteed too per above check)
            m = (3 * self.x**2 + self.curve.a) * inv(2 * self.y, self.curve.p)
        else:
            m = (self.y - other.y) * inv(self.x - other.x, self.curve.p)
        # compute the new point
        rx = (m**2 - self.x - other.x) % self.curve.p
        ry = (-(m*(rx - self.x) + self.y)) % self.curve.p
        return Point(self.curve, rx, ry)

    def __rmul__(self, k: int) -> Point:
        assert isinstance(k, int) and k >= 0
        result = INF
        append = self
        while k:
            if k & 1:
                result += append
            append += append
            k >>= 1
        return result

@dataclass
class Generator:
    """
    A generator over a curve: an initial point and the (pre-computed) order
    """
    G: Point     # a generator point on the curve
    n: int       # the order of the generating point, so 0*G = n*G = INF

INF = Point(None, None, None)

```


## Content of ripemd160.py

```python
"""
Implementing SHA-256 from scratch was fun, but for RIPEMD160 I am
taking an existing implementation and made some cleanups and api changes.
"""

## ripemd.py - pure Python implementation of the RIPEMD-160 algorithm.
## Bjorn Edstrom <be@bjrn.se> 16 december 2007.
##
## Copyrights
## ==========
##
## This code is a derived from an implementation by Markus Friedl which is
## subject to the following license. This Python implementation is not
## subject to any other license.
##
##/*
## * Copyright (c) 2001 Markus Friedl.  All rights reserved.
## *
## * Redistribution and use in source and binary forms, with or without
## * modification, are permitted provided that the following conditions
## * are met:
## * 1. Redistributions of source code must retain the above copyright
## *    notice, this list of conditions and the following disclaimer.
## * 2. Redistributions in binary form must reproduce the above copyright
## *    notice, this list of conditions and the following disclaimer in the
## *    documentation and/or other materials provided with the distribution.
## *
## * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
## * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
## * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
## * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
## * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
## * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE,
## * DATA, OR PROFITS OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
## * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
## * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
## * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
## */
##/*
## * Preneel, Bosselaers, Dobbertin, "The Cryptographic Hash Function RIPEMD-160",
## * RSA Laboratories, CryptoBytes, Volume 3, Number 2, Autumn 1997,
## * ftp://ftp.rsasecurity.com/pub/cryptobytes/crypto3n2.pdf
## */

import sys
import struct

# -----------------------------------------------------------------------------
# public interface

def ripemd160(b: bytes) -> bytes:
    """ simple wrapper for a simpler API to this hash function, just bytes to bytes """
    ctx = RMDContext()
    RMD160Update(ctx, b, len(b))
    digest = RMD160Final(ctx)
    return digest

# -----------------------------------------------------------------------------

class RMDContext:
    def __init__(self):
        self.state = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0] # uint32
        self.count = 0 # uint64
        self.buffer = [0]*64 # uchar

def RMD160Update(ctx, inp, inplen):
    have = int((ctx.count // 8) % 64)
    inplen = int(inplen)
    need = 64 - have
    ctx.count += 8 * inplen
    off = 0
    if inplen >= need:
        if have:
            for i in range(need):
                ctx.buffer[have+i] = inp[i]
            RMD160Transform(ctx.state, ctx.buffer)
            off = need
            have = 0
        while off + 64 <= inplen:
            RMD160Transform(ctx.state, inp[off:]) #<---
            off += 64
    if off < inplen:
        for i in range(inplen - off):
            ctx.buffer[have+i] = inp[off+i]

def RMD160Final(ctx):
    size = struct.pack("<Q", ctx.count)
    padlen = 64 - ((ctx.count // 8) % 64)
    if padlen < 1 + 8:
        padlen += 64
    RMD160Update(ctx, PADDING, padlen-8)
    RMD160Update(ctx, size, 8)
    return struct.pack("<5L", *ctx.state)

# -----------------------------------------------------------------------------

K0 = 0x00000000
K1 = 0x5A827999
K2 = 0x6ED9EBA1
K3 = 0x8F1BBCDC
K4 = 0xA953FD4E
KK0 = 0x50A28BE6
KK1 = 0x5C4DD124
KK2 = 0x6D703EF3
KK3 = 0x7A6D76E9
KK4 = 0x00000000

PADDING = [0x80] + [0]*63

def ROL(n, x):
    return ((x << n) & 0xffffffff) | (x >> (32 - n))

def F0(x, y, z):
    return x ^ y ^ z

def F1(x, y, z):
    return (x & y) | (((~x) % 0x100000000) & z)

def F2(x, y, z):
    return (x | ((~y) % 0x100000000)) ^ z

def F3(x, y, z):
    return (x & z) | (((~z) % 0x100000000) & y)

def F4(x, y, z):
    return x ^ (y | ((~z) % 0x100000000))

def R(a, b, c, d, e, Fj, Kj, sj, rj, X):
    a = ROL(sj, (a + Fj(b, c, d) + X[rj] + Kj) % 0x100000000) + e
    c = ROL(10, c)
    return a % 0x100000000, c

def RMD160Transform(state, block): #uint32 state[5], uchar block[64]

    x = [0]*16
    assert sys.byteorder == 'little', "Only little endian is supported atm for RIPEMD160"
    x = struct.unpack('<16L', bytes(block[0:64]))

    a = state[0]
    b = state[1]
    c = state[2]
    d = state[3]
    e = state[4]

    #/* Round 1 */
    a, c = R(a, b, c, d, e, F0, K0, 11,  0, x)
    e, b = R(e, a, b, c, d, F0, K0, 14,  1, x)
    d, a = R(d, e, a, b, c, F0, K0, 15,  2, x)
    c, e = R(c, d, e, a, b, F0, K0, 12,  3, x)
    b, d = R(b, c, d, e, a, F0, K0,  5,  4, x)
    a, c = R(a, b, c, d, e, F0, K0,  8,  5, x)
    e, b = R(e, a, b, c, d, F0, K0,  7,  6, x)
    d, a = R(d, e, a, b, c, F0, K0,  9,  7, x)
    c, e = R(c, d, e, a, b, F0, K0, 11,  8, x)
    b, d = R(b, c, d, e, a, F0, K0, 13,  9, x)
    a, c = R(a, b, c, d, e, F0, K0, 14, 10, x)
    e, b = R(e, a, b, c, d, F0, K0, 15, 11, x)
    d, a = R(d, e, a, b, c, F0, K0,  6, 12, x)
    c, e = R(c, d, e, a, b, F0, K0,  7, 13, x)
    b, d = R(b, c, d, e, a, F0, K0,  9, 14, x)
    a, c = R(a, b, c, d, e, F0, K0,  8, 15, x) #/* #15 */
    #/* Round 2 */
    e, b = R(e, a, b, c, d, F1, K1,  7,  7, x)
    d, a = R(d, e, a, b, c, F1, K1,  6,  4, x)
    c, e = R(c, d, e, a, b, F1, K1,  8, 13, x)
    b, d = R(b, c, d, e, a, F1, K1, 13,  1, x)
    a, c = R(a, b, c, d, e, F1, K1, 11, 10, x)
    e, b = R(e, a, b, c, d, F1, K1,  9,  6, x)
    d, a = R(d, e, a, b, c, F1, K1,  7, 15, x)
    c, e = R(c, d, e, a, b, F1, K1, 15,  3, x)
    b, d = R(b, c, d, e, a, F1, K1,  7, 12, x)
    a, c = R(a, b, c, d, e, F1, K1, 12,  0, x)
    e, b = R(e, a, b, c, d, F1, K1, 15,  9, x)
    d, a = R(d, e, a, b, c, F1, K1,  9,  5, x)
    c, e = R(c, d, e, a, b, F1, K1, 11,  2, x)
    b, d = R(b, c, d, e, a, F1, K1,  7, 14, x)
    a, c = R(a, b, c, d, e, F1, K1, 13, 11, x)
    e, b = R(e, a, b, c, d, F1, K1, 12,  8, x) #/* #31 */
    #/* Round 3 */
    d, a = R(d, e, a, b, c, F2, K2, 11,  3, x)
    c, e = R(c, d, e, a, b, F2, K2, 13, 10, x)
    b, d = R(b, c, d, e, a, F2, K2,  6, 14, x)
    a, c = R(a, b, c, d, e, F2, K2,  7,  4, x)
    e, b = R(e, a, b, c, d, F2, K2, 14,  9, x)
    d, a = R(d, e, a, b, c, F2, K2,  9, 15, x)
    c, e = R(c, d, e, a, b, F2, K2, 13,  8, x)
    b, d = R(b, c, d, e, a, F2, K2, 15,  1, x)
    a, c = R(a, b, c, d, e, F2, K2, 14,  2, x)
    e, b = R(e, a, b, c, d, F2, K2,  8,  7, x)
    d, a = R(d, e, a, b, c, F2, K2, 13,  0, x)
    c, e = R(c, d, e, a, b, F2, K2,  6,  6, x)
    b, d = R(b, c, d, e, a, F2, K2,  5, 13, x)
    a, c = R(a, b, c, d, e, F2, K2, 12, 11, x)
    e, b = R(e, a, b, c, d, F2, K2,  7,  5, x)
    d, a = R(d, e, a, b, c, F2, K2,  5, 12, x) #/* #47 */
    #/* Round 4 */
    c, e = R(c, d, e, a, b, F3, K3, 11,  1, x)
    b, d = R(b, c, d, e, a, F3, K3, 12,  9, x)
    a, c = R(a, b, c, d, e, F3, K3, 14, 11, x)
    e, b = R(e, a, b, c, d, F3, K3, 15, 10, x)
    d, a = R(d, e, a, b, c, F3, K3, 14,  0, x)
    c, e = R(c, d, e, a, b, F3, K3, 15,  8, x)
    b, d = R(b, c, d, e, a, F3, K3,  9, 12, x)
    a, c = R(a, b, c, d, e, F3, K3,  8,  4, x)
    e, b = R(e, a, b, c, d, F3, K3,  9, 13, x)
    d, a = R(d, e, a, b, c, F3, K3, 14,  3, x)
    c, e = R(c, d, e, a, b, F3, K3,  5,  7, x)
    b, d = R(b, c, d, e, a, F3, K3,  6, 15, x)
    a, c = R(a, b, c, d, e, F3, K3,  8, 14, x)
    e, b = R(e, a, b, c, d, F3, K3,  6,  5, x)
    d, a = R(d, e, a, b, c, F3, K3,  5,  6, x)
    c, e = R(c, d, e, a, b, F3, K3, 12,  2, x) #/* #63 */
    #/* Round 5 */
    b, d = R(b, c, d, e, a, F4, K4,  9,  4, x)
    a, c = R(a, b, c, d, e, F4, K4, 15,  0, x)
    e, b = R(e, a, b, c, d, F4, K4,  5,  5, x)
    d, a = R(d, e, a, b, c, F4, K4, 11,  9, x)
    c, e = R(c, d, e, a, b, F4, K4,  6,  7, x)
    b, d = R(b, c, d, e, a, F4, K4,  8, 12, x)
    a, c = R(a, b, c, d, e, F4, K4, 13,  2, x)
    e, b = R(e, a, b, c, d, F4, K4, 12, 10, x)
    d, a = R(d, e, a, b, c, F4, K4,  5, 14, x)
    c, e = R(c, d, e, a, b, F4, K4, 12,  1, x)
    b, d = R(b, c, d, e, a, F4, K4, 13,  3, x)
    a, c = R(a, b, c, d, e, F4, K4, 14,  8, x)
    e, b = R(e, a, b, c, d, F4, K4, 11, 11, x)
    d, a = R(d, e, a, b, c, F4, K4,  8,  6, x)
    c, e = R(c, d, e, a, b, F4, K4,  5, 15, x)
    b, d = R(b, c, d, e, a, F4, K4,  6, 13, x) #/* #79 */

    aa = a
    bb = b
    cc = c
    dd = d
    ee = e

    a = state[0]
    b = state[1]
    c = state[2]
    d = state[3]
    e = state[4]

    #/* Parallel round 1 */
    a, c = R(a, b, c, d, e, F4, KK0,  8,  5, x)
    e, b = R(e, a, b, c, d, F4, KK0,  9, 14, x)
    d, a = R(d, e, a, b, c, F4, KK0,  9,  7, x)
    c, e = R(c, d, e, a, b, F4, KK0, 11,  0, x)
    b, d = R(b, c, d, e, a, F4, KK0, 13,  9, x)
    a, c = R(a, b, c, d, e, F4, KK0, 15,  2, x)
    e, b = R(e, a, b, c, d, F4, KK0, 15, 11, x)
    d, a = R(d, e, a, b, c, F4, KK0,  5,  4, x)
    c, e = R(c, d, e, a, b, F4, KK0,  7, 13, x)
    b, d = R(b, c, d, e, a, F4, KK0,  7,  6, x)
    a, c = R(a, b, c, d, e, F4, KK0,  8, 15, x)
    e, b = R(e, a, b, c, d, F4, KK0, 11,  8, x)
    d, a = R(d, e, a, b, c, F4, KK0, 14,  1, x)
    c, e = R(c, d, e, a, b, F4, KK0, 14, 10, x)
    b, d = R(b, c, d, e, a, F4, KK0, 12,  3, x)
    a, c = R(a, b, c, d, e, F4, KK0,  6, 12, x) #/* #15 */
    #/* Parallel round 2 */
    e, b = R(e, a, b, c, d, F3, KK1,  9,  6, x)
    d, a = R(d, e, a, b, c, F3, KK1, 13, 11, x)
    c, e = R(c, d, e, a, b, F3, KK1, 15,  3, x)
    b, d = R(b, c, d, e, a, F3, KK1,  7,  7, x)
    a, c = R(a, b, c, d, e, F3, KK1, 12,  0, x)
    e, b = R(e, a, b, c, d, F3, KK1,  8, 13, x)
    d, a = R(d, e, a, b, c, F3, KK1,  9,  5, x)
    c, e = R(c, d, e, a, b, F3, KK1, 11, 10, x)
    b, d = R(b, c, d, e, a, F3, KK1,  7, 14, x)
    a, c = R(a, b, c, d, e, F3, KK1,  7, 15, x)
    e, b = R(e, a, b, c, d, F3, KK1, 12,  8, x)
    d, a = R(d, e, a, b, c, F3, KK1,  7, 12, x)
    c, e = R(c, d, e, a, b, F3, KK1,  6,  4, x)
    b, d = R(b, c, d, e, a, F3, KK1, 15,  9, x)
    a, c = R(a, b, c, d, e, F3, KK1, 13,  1, x)
    e, b = R(e, a, b, c, d, F3, KK1, 11,  2, x) #/* #31 */
    #/* Parallel round 3 */
    d, a = R(d, e, a, b, c, F2, KK2,  9, 15, x)
    c, e = R(c, d, e, a, b, F2, KK2,  7,  5, x)
    b, d = R(b, c, d, e, a, F2, KK2, 15,  1, x)
    a, c = R(a, b, c, d, e, F2, KK2, 11,  3, x)
    e, b = R(e, a, b, c, d, F2, KK2,  8,  7, x)
    d, a = R(d, e, a, b, c, F2, KK2,  6, 14, x)
    c, e = R(c, d, e, a, b, F2, KK2,  6,  6, x)
    b, d = R(b, c, d, e, a, F2, KK2, 14,  9, x)
    a, c = R(a, b, c, d, e, F2, KK2, 12, 11, x)
    e, b = R(e, a, b, c, d, F2, KK2, 13,  8, x)
    d, a = R(d, e, a, b, c, F2, KK2,  5, 12, x)
    c, e = R(c, d, e, a, b, F2, KK2, 14,  2, x)
    b, d = R(b, c, d, e, a, F2, KK2, 13, 10, x)
    a, c = R(a, b, c, d, e, F2, KK2, 13,  0, x)
    e, b = R(e, a, b, c, d, F2, KK2,  7,  4, x)
    d, a = R(d, e, a, b, c, F2, KK2,  5, 13, x) #/* #47 */
    #/* Parallel round 4 */
    c, e = R(c, d, e, a, b, F1, KK3, 15,  8, x)
    b, d = R(b, c, d, e, a, F1, KK3,  5,  6, x)
    a, c = R(a, b, c, d, e, F1, KK3,  8,  4, x)
    e, b = R(e, a, b, c, d, F1, KK3, 11,  1, x)
    d, a = R(d, e, a, b, c, F1, KK3, 14,  3, x)
    c, e = R(c, d, e, a, b, F1, KK3, 14, 11, x)
    b, d = R(b, c, d, e, a, F1, KK3,  6, 15, x)
    a, c = R(a, b, c, d, e, F1, KK3, 14,  0, x)
    e, b = R(e, a, b, c, d, F1, KK3,  6,  5, x)
    d, a = R(d, e, a, b, c, F1, KK3,  9, 12, x)
    c, e = R(c, d, e, a, b, F1, KK3, 12,  2, x)
    b, d = R(b, c, d, e, a, F1, KK3,  9, 13, x)
    a, c = R(a, b, c, d, e, F1, KK3, 12,  9, x)
    e, b = R(e, a, b, c, d, F1, KK3,  5,  7, x)
    d, a = R(d, e, a, b, c, F1, KK3, 15, 10, x)
    c, e = R(c, d, e, a, b, F1, KK3,  8, 14, x) #/* #63 */
    #/* Parallel round 5 */
    b, d = R(b, c, d, e, a, F0, KK4,  8, 12, x)
    a, c = R(a, b, c, d, e, F0, KK4,  5, 15, x)
    e, b = R(e, a, b, c, d, F0, KK4, 12, 10, x)
    d, a = R(d, e, a, b, c, F0, KK4,  9,  4, x)
    c, e = R(c, d, e, a, b, F0, KK4, 12,  1, x)
    b, d = R(b, c, d, e, a, F0, KK4,  5,  5, x)
    a, c = R(a, b, c, d, e, F0, KK4, 14,  8, x)
    e, b = R(e, a, b, c, d, F0, KK4,  6,  7, x)
    d, a = R(d, e, a, b, c, F0, KK4,  8,  6, x)
    c, e = R(c, d, e, a, b, F0, KK4, 13,  2, x)
    b, d = R(b, c, d, e, a, F0, KK4,  6, 13, x)
    a, c = R(a, b, c, d, e, F0, KK4,  5, 14, x)
    e, b = R(e, a, b, c, d, F0, KK4, 15,  0, x)
    d, a = R(d, e, a, b, c, F0, KK4, 13,  3, x)
    c, e = R(c, d, e, a, b, F0, KK4, 11,  9, x)
    b, d = R(b, c, d, e, a, F0, KK4, 11, 11, x) #/* #79 */

    t = (state[1] + cc + d) % 0x100000000
    state[1] = (state[2] + dd + e) % 0x100000000
    state[2] = (state[3] + ee + a) % 0x100000000
    state[3] = (state[4] + aa + b) % 0x100000000
    state[4] = (state[0] + bb + c) % 0x100000000
    state[0] = t % 0x100000000

```


## Content of block.py

```python
"""
The Block object in Bitcoin
Reference:
- https://en.bitcoin.it/wiki/Block
- https://en.bitcoin.it/wiki/Block_hashing_algorithm
"""

from __future__ import annotations # PEP 563: Postponed Evaluation of Annotations
from dataclasses import dataclass
from typing import Dict, List, Tuple, Union

from .sha256 import sha256

# -----------------------------------------------------------------------------
# Block headers, 80 bytes
GENESIS_BLOCK = {
    'main': bytes.fromhex('0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c'),
    'test': bytes.fromhex('0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff001d1aa4ae18'),
}
# -----------------------------------------------------------------------------
# helper functions

def decode_int(s, nbytes, encoding='little'):
    return int.from_bytes(s.read(nbytes), encoding)

def encode_int(i, nbytes, encoding='little'):
    return i.to_bytes(nbytes, encoding)

def bits_to_target(bits):
    exponent = bits[-1]
    coeff = int.from_bytes(bits[:-1], 'little')
    target = coeff * 256**(exponent - 3)
    return target

def target_to_bits(target):
    b = target.to_bytes(32, 'big')
    b = b.lstrip(b'\x00')
    if b[0] >= 128:
        # leading bit is a 1, which would interpret this as negative number
        # shift everything over by 1 byte because for us target is always positive
        exponent = len(b) + 1 # how long the number is in base 256
        coeff = b'\x00' + b[:2] # first three digits of the base 256 number
    else:
        exponent = len(b)
        coeff = b[:3]
    # encode coeff in little endian and exponent is at the end
    new_bits = coeff[::-1] + bytes([exponent])
    return new_bits

def calculate_new_bits(prev_bits, dt):
    two_weeks = 60*60*24*14 # number of seconds in two week period
    dt = max(min(dt, two_weeks*4), two_weeks//4)
    prev_target = bits_to_target(prev_bits)
    new_target = int(prev_target * dt / two_weeks)
    new_target = min(new_target, 0xffff * 256**(0x1d - 3)) # cap maximum target
    new_bits = target_to_bits(new_target)
    return new_bits

# -----------------------------------------------------------------------------

@dataclass
class Block:
    version: int        # 4 bytes little endian
    prev_block: bytes   # 32 bytes, little endian
    merkle_root: bytes  # 32 bytes, little endian
    timestamp: int      # uint32, seconds since 1970-01-01T00:00 UTC
    bits: bytes         # 4 bytes, current target in compact format
    nonce: bytes        # 4 bytes, searched over in pow

    @classmethod
    def decode(cls, s) -> Block:
        version = decode_int(s, 4)
        prev_block = s.read(32)[::-1]
        merkle_root = s.read(32)[::-1]
        timestamp = decode_int(s, 4)
        bits = s.read(4)
        nonce = s.read(4)
        return cls(version, prev_block, merkle_root, timestamp, bits, nonce)

    def encode(self) -> bytes:
        out = []
        out += [encode_int(self.version, 4)]
        out += [self.prev_block[::-1]]
        out += [self.merkle_root[::-1]]
        out += [encode_int(self.timestamp, 4)]
        out += [self.bits]
        out += [self.nonce]
        return b''.join(out)

    def id(self) -> str:
        return sha256(sha256(self.encode()))[::-1].hex()

    def target(self) -> int:
        return bits_to_target(self.bits)

    def difficulty(self) -> float:
        genesis_block_target = 0xffff * 256**(0x1d - 3)
        diff = genesis_block_target / self.target()
        return diff

    def validate(self) -> bool:
        """ validate this block """
        # 1) validate bits (target) field (todo)
        # 2) validate proof of work
        if int(self.id(), 16) >= self.target():
            return False
        # if everything passes the block is good
        return True

```
